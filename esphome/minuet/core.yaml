# MINUET CORE PACKAGE
# SUPPORTED HARDWARE: Minuet v3.0
#
# ESPHome package for the Minuet fan controller built-in components.
#
# Include the contents of this file into your device configuration YAML
# file as a package like this (recommended):
#
# packages:
#   <<: !include minuet/core.yaml
#
# The fan controller makes use of most of the GPIO pins for controlling the
# motors and the keypad. Please take care when making modifications to this
# file to prevent malfunction.
#
# To expand the capabilities of your Minuet fan controller, you may attach
# additional components to the I2C bus using the QWIIC connection and
# use GPIO0, GPIO1, GPIO5, GPIO6, GPIO20 (RXD), GPIO21 (TXD) which are presented
# at the GPIO expansion port for accessories.
minuet_components:
  # Include external ESPHome components
  external_components:
    - source: github://j9brown/esphome-maxxfan-protocol@main
      components: [ maxxfan_protocol ]
      refresh: 1min
    # - source: github://j9brown/esphome-mcf8316@main
    #   components: [ mcf8316 ]
    - source: ../../esphome-mcf8316/components

  # Configure build options
  esphome:
    includes:
      - minuet/core.h
      - minuet/fan_motor.h
    platformio_options:
      build_flags: >
        -Wno-packed-bitfield-compat
        -DCONFIG_ADC_SUPPRESS_DEPRECATE_WARN=1

  # Configure the board
  esp32:
    board: esp32-c3-devkitm-1
    framework:
      type: esp-idf

  # The I2C bus is used by built-in components and is presented via a
  # QWIIC connector on the board edge for accessories
  i2c:
    - id: minuet_i2c
      scl:
        number: 8
        ignore_strapping_warning: true
      sda:
        number: 7
      scan: true
      frequency: 100kHz

  # The built-in TCA9555 provides additional 16 GPIO pins, all of which are
  # used by built-in functions. If you need more GPIO pins, you can attach another
  # GPIO expander via the QWIIC port, taking care to assign it an unused I2C address.
  pca9554:
    - id: minuet_xio
      i2c_id: minuet_i2c
      address: 0x20
      pin_count: 16


# Vent fan motor driver
# TODO:
# - Add keep awake setting to help with tuning (never sleep)
# - Add select entity for motor descriptor
# - Add service to set custom motor parameters
minuet_fan_motor_driver:
  mcf8316:
    - id: minuet_fan_motor_driver
      wake:
        pca9554: minuet_xio
        number: 13
        mode: output
      nfault:
        pca9554: minuet_xio
        number: 12
        mode: input
      watchdog: true
      on_fault:
        then:
          - lambda: |-
              if (x.is_faulted()) {
                ESP_LOGD(minuet::TAG, "Fan stalled, disabling the motor for safety");
                id(minuet_fan)->turn_off().perform();
              }
  sensor:
    - id: minuet_fan_motor_tach
      name: "Fan Tachometer"
      icon: mdi:fan
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: rpm
      accuracy_decimals: 0
      platform: template
      update_interval: 5s
      filters:
        - round_to_multiple_of: 10
        - delta: 5
      lambda: 'return minuet::fan_motor::control.get_tachometer_rpm();'
    - id: minuet_fan_driver_bus_current
      name: "Fan Driver Bus Current"
      state_class: measurement
      device_class: current
      entity_category: diagnostic
      unit_of_measurement: A
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - round_to_multiple_of: 0.01
        - delta: 0.005
      lambda: 'return minuet::fan_motor::control.get_bus_current();'
    - id: minuet_fan_driver_motor_phase_peak_current
      name: "Fan Driver Motor Phase Peak Current"
      state_class: measurement
      device_class: current
      entity_category: diagnostic
      unit_of_measurement: A
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - round_to_multiple_of: 0.01
        - delta: 0.005
      lambda: 'return minuet::fan_motor::control.get_motor_phase_peak_current();'
    - id: minuet_fan_driver_vm_voltage
      name: "Fan Driver VM Voltage"
      state_class: measurement
      device_class: voltage
      entity_category: diagnostic
      unit_of_measurement: V
      accuracy_decimals: 2
      disabled_by_default: true
      platform: template
      update_interval: never
      filters:
        - round_to_multiple_of: 0.01
        - delta: 0.005
      lambda: 'return minuet::fan_motor::control.get_vm_voltage();'
  switch:
    - id: minuet_fan_driver_diagnostics
      name: "Fan Driver Diagnostics"
      icon: mdi:bug-outline
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: diagnostic
      disabled_by_default: true
  button:
    - id: minuet_fan_motor_mpet
      name: "Start Motor Parameter Extraction Tool"
      icon: mdi:gear
      platform: template
      disabled_by_default: true
      entity_category: config
      on_press:
        then:
          - lambda: |-
              minuet::fan_motor::control.start_mpet();
  esphome:
    on_boot:
      - priority: 550
        then:
          - lambda: |-
              // TODO: allow the motor to be configured
              minuet::fan_motor::control.init(minuet::fan_motor::MOTORS[0]);
  interval:
    - interval: 1s
      then:
        lambda: |-
          if (id(minuet_fan_driver_diagnostics).state) {
            id(minuet_fan_driver_bus_current).update();
            id(minuet_fan_driver_motor_phase_peak_current).update();
            id(minuet_fan_driver_vm_voltage).update();
          }


# Vent cover motor driver
minuet_cover_motor_driver:
  binary_sensor:
    - id: minuet_cover_motor_fault
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 9
        mode: input
        inverted: true
      trigger_on_initial_state: true
      use_interrupt: false
  output:
    - id: minuet_cover_motor_sleep
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 10
        mode: output
        inverted: true
    - id: minuet_cover_motor_open
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 11
        mode: output
        inverted: false


# Ambient temperature sensor
minuet_ambient_temperature_sensor:
  sensor:
    - id: minuet_thermistor_voltage
      platform: adc
      pin: 4
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 20
            send_every: 10
            send_first_at: 10
        - delta: 0.001
      update_interval: never
    - id: minuet_thermistor_resistance
      platform: resistance
      sensor: minuet_thermistor_voltage
      configuration: DOWNSTREAM
      resistor: 10kOhm
    - id: minuet_ambient_temperature
      platform: ntc
      sensor: minuet_thermistor_resistance
      calibration:
        b_constant: 3950
        reference_temperature: 25Â°C
        reference_resistance: 10kOhm
      accuracy_decimals: 1
      filters:
        - round_to_multiple_of: 0.2
        - delta: 0.1
  output:
    - id: minuet_thermistor_power
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 14
        mode: output
        inverted: false
  interval:
    - interval: 0.5s
      then:
        lambda: |-
          id(minuet_thermistor_power).turn_on();
          id(minuet_thermistor_voltage).update();
          id(minuet_thermistor_power).turn_off();


# Battery monitor
minuet_battery_monitor:
  binary_sensor:
    - id: minuet_battery_problem
      name: "Battery Problem"
      device_class: problem
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
  sensor:
    - id: minuet_battery_voltage
      name: "Battery Voltage"
      icon: mdi:car-battery
      device_class: voltage
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: V
      accuracy_decimals: 1
      platform: adc
      pin: 3
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 10
            send_every: 5
            send_first_at: 5
        - multiply: 11
        - round_to_multiple_of: 0.1
        - delta: 0.05
      update_interval: 0.5s
      on_value:
        then:
          - lambda: |-
              auto& problem = id(minuet_battery_problem);
              const float hysteresis = problem->state ? 0.4f : 0.f;
              const bool low = x < id(minuet_battery_voltage_low).state + hysteresis;
              const bool high = x > id(minuet_battery_voltage_high).state - hysteresis;
              problem->publish_state(low || high);
  number:
    - id: minuet_battery_voltage_low
      name: "Low Battery Voltage Threshold"
      icon: mdi:battery-alert
      entity_category: config
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 10.8
    - id: minuet_battery_voltage_high
      name: "High Battery Voltage Threshold"
      icon: mdi:battery-alert
      entity_category: config
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 15.2


# Rain sensor
minuet_rain_sensor:
  binary_sensor:
    - id: minuet_rain
      name: "Rain Detected"
      icon: mdi:weather-rainy
      device_class: moisture
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 8
        mode: input
        inverted: true
      use_interrupt: false
      trigger_on_initial_state: true
      filters:
        - delayed_on_off:
            time_on: 2s
            time_off: 60s
      on_press:
        then:
          - lambda: |-
              if (id(minuet_fan).state && id(minuet_rain_sensor_should_stop_fan).state) {
                id(minuet_rain_sensor_did_stop_fan).publish_state(true);
                // TODO: Use safety lock function here instead of modifying the fan state
                id(minuet_fan).make_call().set_state(false).perform();
              }
    - id: minuet_rain_sensor_did_stop_fan
      name: "Rain Stopped Fan"
      device_class: problem
      entity_category: diagnostic
      platform: template
      trigger_on_initial_state: true
  switch:
    - id: minuet_rain_sensor_should_stop_fan
      name: "Stop Fan When Rain Detected"
      icon: mdi:weather-rainy
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_turn_off:
        then:
          - binary_sensor.template.publish:
              id: minuet_rain_sensor_did_stop_fan
              state: OFF
  button:
    - id: minuet_rain_sensor_reset
      name: "Reset Rain Sensor"
      icon: mdi:weather-rainy
      platform: template
      on_press:
        then:
          - binary_sensor.template.publish:
              id: minuet_rain_sensor_did_stop_fan
              state: OFF
          - switch.turn_on: minuet_rain_sensor_should_stop_fan
  esphome:
    on_boot:
      - priority: 800
        then:
          - lambda: |-
              id(minuet_rain_sensor_did_stop_fan).publish_initial_state(false);


# Safety lock
minuet_safety_lock:
  binary_sensor:
    - id: minuet_safety_lock_off
      name: "Safety Lock"
      icon: mdi:lock
      device_class: lock
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 15
        mode: input
      use_interrupt: false
      trigger_on_initial_state: true
      filters:
        - delayed_on_off: 100ms


# Provides audible feedback
minuet_tone:
  substitutions:
    # Tones specified in the RTTTL language
    # Tones whose names start with '!' are important and cannot be suppressed
    #
    # Design guidelines:
    # - Tones start on E6
    # - Incrementing a value rises to G6
    # - Decrementing a value falls to C6
    # - Enabling a feature rises to A6
    # - Disabling a feature falls to A5
    # - Resetting a feature is a turn of E6, F6, E6, D6, E6
    # - Play tones only for actions whose effect cannot be immediately observed
    #   such as changing the thermostat temperature and don't play tones for actions
    #   whose effect can be immediately observed such as changing the fan speed
    # - Of course, if you're customizing this firmware you can change the tones to
    #   anything you like!
    #
    # Useful tool for testing tones: https://adamonsoon.github.io/rtttl-play/
    minuet_tones: |-
      // Generic tones
      "beep:d=16,o=4,b=144:e6",
      "!urgent:d=16,o=4,b=144:32e6,32p,e6",
      "minuet:d=4,o=4,b=152:d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,f#4,8g4,8a4,8b4,8g4,32b4,2a4.,d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,a4,8b4,8a4,8g4,8f#4,2g4.",
      // Specific actions
      "manual_fan_on:",
      "manual_fan_off:",
      "manual_speed_up:",
      "manual_speed_down:",
      "manual_dir_in:",
      "manual_dir_out:",
      "manual_cover_open:",
      "manual_cover_close:",
      "auto_on:",
      "auto_off:",
      "auto_temp_up:d=16,o=4,b=144:e6,g6",
      "auto_temp_down:d=16,o=4,b=144:e6,c6",
      "auto_temp_default:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6",
      "auto_fan_on:d=16,o=4,b=144:e6,p,8a6",
      "auto_fan_off:d=16,o=4,b=144:e6,p,8a5",
      "auto_dir_in:d=16,o=4,b=144:32e6,32d6,8c6",
      "auto_dir_out:d=16,o=4,b=144:32e6,32f6,8g6",
      "auto_dir_same:d=16,o=4,b=144:32e6,32p,8e6",
      "rain_on:",
      "rain_off:",
      "ir_confirm:",
      "ir_warn:d=16,o=4,b=144:32e6,32p,e6",
      "!controls_enhanced:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a6",
      "!controls_standard:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a5",
      "!wifi_on:d=16,o=4,b=144:32e6,32p,32e6,32p,8a6",
      "!wifi_off:d=16,o=4,b=144:32e6,32p,32e6,32p,8a5",
      "!power_on_restore:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a6",
      "!power_on_default:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a5",
      "!factory_reset:d=16,o=4,b=144:8e6,8a5,8e5,4a4",
    minuet_tone_default_if_unknown: "beep"
  output:
    - id: minuet_tone_pwm
      platform: ledc
      pin:
        number: 10
        mode: output
        inverted: false
      channel: 3
  rtttl:
    - id: minuet_tone_generator
      output: minuet_tone_pwm
  switch:
    - id: minuet_tone_enable
      name: "Audible Feedback"
      icon: mdi:volume-high
      entity_category: config
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_turn_off:
        then:
          - rtttl.stop:
  api:
    actions:
      - action: play_tone
        variables:
          name: string
        then:
          - lambda: id(minuet_tone)->execute(name);
      - action: play_tone_rtttl
        variables:
          tone: string
        then:
          - lambda: id(minuet_tone_rtttl)->execute(tone);
      - action: stop_tone
        then:
          - rtttl.stop:
  script:
    - id: minuet_tone
      parameters:
        name: string
      then:
        - lambda: |-
            constexpr const char* tones[] = { ${minuet_tones} };
            constexpr const char* default_if_unknown = "${minuet_tone_default_if_unknown}";
            for (;;) {
              for (size_t i = 0; i < sizeof(tones) / sizeof(tones[0]); i++) {
                const char* tone = tones[i];
                char* colon_pos = strchr(tone, ':');
                if (!colon_pos) {
                  ESP_LOGD(minuet::TAG, "RTTTL tone missing name: '%s'", tone);
                  continue;
                }
                size_t name_length = colon_pos - tone;
                if (name.size() == name_length && strncmp(name.c_str(), tone, name_length) == 0) {
                  if (colon_pos[1]) { // ensure tone is not empty
                    id(minuet_tone_rtttl)->execute(colon_pos - 1);
                  }
                  return;
                }
              }
              ESP_LOGD(minuet::TAG, "RTTTL tone not found: '%s'", name.c_str());
              if (name == default_if_unknown) {
                return;
              }
              name = default_if_unknown;
            }
    - id: minuet_tone_rtttl
      parameters:
        tone: string
      then:
        - lambda: |-
            if (id(minuet_tone_enable).state || tone[0] == '!') {
              id(minuet_tone_generator).play(tone);
            }
  button:
    - id: minuet_beep
      name: Beep
      icon: mdi:alert
      disabled_by_default: true
      entity_category: config
      platform: template
      on_press:
        then:
          - script.execute:
              id: minuet_tone
              name: beep


# Read the keypad controls and determine an action
# Refer to the user guide for the control scheme
minuet_keypad_control:
  globals:
    - id: minuet_keypad_bouncy_key_state
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_bouncy_key_time
      type: uint32_t
      restore_value: false
      initial_value: "millis()"
    - id: minuet_keypad_last_key_state
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_last_key_valid
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_last_key_time
      type: uint32_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_auto_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_rain_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_wifi_switch # Injected by wifi.yaml
      type: Switch*
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_toggle # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_up # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_down # Injected by accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
  button:
    - id: minuet_restart
      platform: restart
      name: Restart
      icon: mdi:restart
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset
      platform: factory_reset
      name: Factory Reset
      icon: mdi:restart-alert
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset_after_delay
      platform: template
      on_press:
        then:
          - delay: 2s
          - button.press: minuet_factory_reset
  output:
    - id: minuet_keypad_auto_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 0
        mode: output
        inverted: true
    - id: minuet_keypad_rain_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 1
        mode: output
        inverted: true
  interval:
    - interval: 10ms
      then:
        lambda: |-
          // Determine which menu of keypad actions is active.
          enum class Menu {
            STANDARD_MANUAL, STANDARD_AUTO, ENHANCED,
          };
          const auto which_menu = []() -> Menu {
            if (id(minuet_controls).active_index() == 1 /*Enhanced*/) return Menu::ENHANCED;
            return id(minuet_thermostat).mode == CLIMATE_MODE_OFF ? Menu::STANDARD_MANUAL : Menu::STANDARD_AUTO;
          };

          // Declare all of the possible actions
          // This code might be tidier in separate functions but that would require putting them
          // in a separate header file which is less convenient
          const auto do_press_power = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->turn_off().perform();
                id(minuet_tone)->execute("manual_fan_off");
              } else {
                fan->turn_on().perform();
                id(minuet_tone)->execute("manual_fan_on");
              }
            }
          };
          const auto do_press_4_on = [which_menu]() {
            auto& fan = id(minuet_fan);
            if (fan->state) {
              const auto SPEED_CYCLE = { 1, 3, 7, 10, };
              const auto it = std::find_if(SPEED_CYCLE.begin(), SPEED_CYCLE.end(), [](int speed) { return speed > fan->speed; });
              const bool going_up = it != SPEED_CYCLE.end();
              fan->make_call().set_speed(going_up ? *it : *SPEED_CYCLE.begin()).perform();
              id(minuet_tone)->execute(going_up ? "manual_speed_up" : "manual_speed_down");
            } else {
              fan->turn_on().perform();
              id(minuet_tone)->execute("manual_fan_on");
            }
          };
          const auto do_press_4_off = [which_menu]() {
            auto& fan = id(minuet_fan);
            fan->turn_off().perform();
            id(minuet_tone)->execute("manual_fan_off");
          };
          const auto do_press_up = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed + 1).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
            }
          };
          const auto do_hold_up = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->get_traits().supported_speed_count()).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
              return true;
            }
            return false;
          };
          const auto do_press_down = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
                id(minuet_tone)->execute("auto_temp_down");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed - 1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
            }
          };
          const auto do_hold_down = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
              return true;
            }
            return false;
          };
          const auto do_press_open_close = [which_menu]() {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& cover = id(minuet_cover);
              if (id(minuet_cover).is_fully_closed()) {
                cover->make_call().set_command_open().perform();
                id(minuet_tone)->execute("manual_cover_open");
              } else {
                cover->make_call().set_command_close().perform();
                id(minuet_tone)->execute("manual_cover_close");
              }
            }
          };
          const auto do_press_4_open = [which_menu]() {
            auto& cover = id(minuet_cover);
            cover->make_call().set_command_open().perform();
            id(minuet_tone)->execute("manual_cover_open");
          };
          const auto do_press_4_close = [which_menu]() {
            auto& cover = id(minuet_cover);
            cover->make_call().set_command_close().perform();
            id(minuet_tone)->execute("manual_cover_close");
          };
          const auto do_press_direction = [which_menu]() {
            auto& fan = id(minuet_fan);
            if (fan->state) {
              const bool exhaust = !minuet::fan_direction_is_exhaust(fan->direction);
              fan->make_call().set_direction(minuet::fan_direction(exhaust)).perform();
              id(minuet_tone)->execute(exhaust ? "manual_dir_out" : "manual_dir_in");
            }
          };
          const auto do_press_auto = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else if (menu == Menu::STANDARD_MANUAL) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
              id(minuet_tone)->execute("auto_on");
            } else {
              auto& therm = id(minuet_thermostat);
              if (therm->mode == CLIMATE_MODE_OFF) {
                therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
                id(minuet_tone)->execute("auto_on");
              } else if (id(minuet_thermostat_override)) {
                id(minuet_thermostat_reset_override).execute();
                id(minuet_tone)->execute("auto_on");
              } else {
                therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
                id(minuet_tone)->execute("auto_off");
              }
            }
          };
          const auto do_press_auto_up = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            }
          };
          const auto do_press_auto_down = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_down");
            }
          };
          const auto do_press_auto_power = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              if (therm->fan_mode == CLIMATE_FAN_OFF) {
                therm->make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform();
                id(minuet_tone)->execute("auto_fan_on");
              } else {
                therm->make_call().set_fan_mode(CLIMATE_FAN_OFF).perform();
                id(minuet_tone)->execute("auto_fan_off");
              }
            }
          };
          const auto do_press_auto_direction = [which_menu]() {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              id(minuet_thermostat_fan_direction).make_call().select_next(true).perform();
              const auto& index = id(minuet_thermostat_fan_direction).active_index();
              id(minuet_tone)->execute(index == 1 ? "auto_dir_out" : index == 2 ? "auto_dir_in" : "auto_dir_same");
            }
          };
          const auto do_hold_auto = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED || menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(fahrenheit_to_celsius(${minuet_thermostat_default_temperature})).perform();
              id(minuet_tone)->execute("auto_temp_default");
              return true;
            }
            return false;
          };
          const auto do_press_rain = [which_menu]() {
            if (id(minuet_rain_sensor_did_stop_fan).state || !id(minuet_rain_sensor_should_stop_fan).state) {
              id(minuet_rain_sensor_reset).press();
              id(minuet_tone)->execute("rain_on");
            } else {
              id(minuet_rain_sensor_should_stop_fan).turn_off();
              id(minuet_tone)->execute("rain_off");
            }
          };
          const auto do_hold_use_enhanced_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(1).perform();
            id(minuet_tone)->execute("!controls_enhanced");
            return true;
          };
          const auto do_hold_use_standard_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(0).perform();
            id(minuet_tone)->execute("!controls_standard");
            return true;
          };
          const auto do_hold_wifi_toggle = [which_menu]() -> bool {
            const auto& wifi_switch = id(minuet_keypad_wifi_switch);
            if (wifi_switch) {
              wifi_switch->toggle();
              id(minuet_tone)->execute(wifi_switch->state ? "!wifi_on" : "!wifi_off");
              return true;
            }
            return false;
          };
          const auto do_hold_power_on_behavior_toggle = [which_menu]() -> bool {
            auto& behavior = id(minuet_power_on_behavior);
            behavior->make_call().select_next(true).perform();
            id(minuet_tone)->execute(behavior->active_index() == 1 ? "!power_on_restore" : "!power_on_default");
            return true;
          };
          const auto do_hold_factory_reset = [which_menu]() -> bool {
            id(minuet_factory_reset_after_delay).press();
            id(minuet_tone)->execute("!factory_reset");
            return true;
          };
          const auto do_hold_accessory_toggle = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_toggle);
            return !!fn && fn();
          };
          const auto do_press_accessory_up = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_up);
            return !!fn && fn();
          };
          const auto do_press_accessory_down = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_down);
            return !!fn && fn();
          };

          // Scan the keypad matrix
          // All of the pins have internal pull-up resistors
          constexpr uint8_t XIO_PIN_R1 = 5;
          constexpr uint8_t XIO_PIN_R2 = 3;
          constexpr uint8_t XIO_PIN_C1 = 7;
          constexpr uint8_t XIO_PIN_C2 = 4;
          constexpr uint8_t XIO_PIN_C3 = 2;
          constexpr uint8_t XIO_PIN_C4 = 6;
          auto& xio = id(minuet_xio);

          // Read the keypad row pins themselves while they are undriven
          // to detect OPEN and CLOSE on the 4 key keypad
          const bool key_r1_gnd = !xio->digital_read(XIO_PIN_R1);
          const bool key_r2_gnd = !xio->digital_read(XIO_PIN_R2);

          // Drive keypad row 1 low and read the columns
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r1_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r1_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r1_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r1_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_INPUT);

          // Drive keypad row 2 low and read the columns
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r2_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r2_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r2_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r2_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_INPUT);

          // Combine all of the key states into a single value with one bit per key
          // that represents the complete state of the keypad
          constexpr uint32_t KEY_UP = 1u << 0;
          constexpr uint32_t KEY_DOWN = 1u << 1;
          constexpr uint32_t KEY_RAIN = 1u << 2;
          constexpr uint32_t KEY_POWER = 1u << 3;
          constexpr uint32_t KEY_DIRECTION = 1u << 4;
          constexpr uint32_t KEY_AUTO = 1u << 5;
          constexpr uint32_t KEY_4_CLOSE = 1u << 6;
          constexpr uint32_t KEY_4_OPEN = 1u << 7;
          constexpr uint32_t KEY_4_OFF = 1u << 8;
          constexpr uint32_t KEY_4_ON = 1u << 9;
          const uint32_t key_state =
              (key_r1_c2 ? KEY_UP : 0) |
              (key_r1_c3 ? KEY_DOWN : 0) |
              (key_r1_c4 ? KEY_RAIN : 0) |
              (key_r2_c2 ? KEY_POWER : 0) |
              (key_r2_c3 ? KEY_DIRECTION : 0) |
              (key_r2_c4 ? KEY_AUTO : 0) |
              (key_r1_gnd ? KEY_4_CLOSE : 0) |
              (key_r2_gnd ? KEY_4_OPEN : 0) |
              (key_r1_c1 ? KEY_4_OFF : 0) |
              (key_r2_c1 ? KEY_4_ON : 0);

          // Debounce the keys
          constexpr uint32_t DEBOUNCE_DURATION = 40;
          auto& bouncy_key_state = id(minuet_keypad_bouncy_key_state);
          auto& bouncy_key_time = id(minuet_keypad_bouncy_key_time);
          if (key_state != bouncy_key_state) {
            bouncy_key_state = key_state;
            bouncy_key_time = millis();
            return; // wait for key state to be debounced before processing it
          }
          if (millis() - bouncy_key_time < DEBOUNCE_DURATION) {
            return; // wait for key state to be debounced before processing it
          }

          // Check whether this key combination is potentially valid
          constexpr uint32_t KEY_COMBO_OPEN_CLOSE = KEY_UP | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_UP = KEY_AUTO | KEY_UP;
          constexpr uint32_t KEY_COMBO_AUTO_DOWN = KEY_AUTO | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_DIRECTION = KEY_AUTO | KEY_DIRECTION;
          constexpr uint32_t KEY_COMBO_AUTO_POWER = KEY_AUTO | KEY_POWER;
          constexpr uint32_t KEY_COMBO_POWER_UP = KEY_POWER | KEY_UP;
          constexpr uint32_t KEY_COMBO_POWER_DOWN = KEY_POWER | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_DIRECTION_UP = KEY_DIRECTION | KEY_UP;
          constexpr uint32_t KEY_COMBO_DIRECTION_DOWN = KEY_DIRECTION | KEY_DOWN;
          const auto VALID_KEY_COMBOS = {
              KEY_UP, KEY_DOWN, KEY_RAIN, KEY_POWER, KEY_DIRECTION, KEY_AUTO,
              KEY_4_CLOSE, KEY_4_OPEN, KEY_4_OFF, KEY_4_ON,
              KEY_COMBO_OPEN_CLOSE,
              KEY_COMBO_AUTO_UP, KEY_COMBO_AUTO_DOWN, KEY_COMBO_AUTO_DIRECTION, KEY_COMBO_AUTO_POWER,
              KEY_COMBO_POWER_UP, KEY_COMBO_POWER_DOWN,
              KEY_COMBO_DIRECTION_UP, KEY_COMBO_DIRECTION_DOWN,
          };
          bool key_valid = std::find(VALID_KEY_COMBOS.begin(), VALID_KEY_COMBOS.end(), key_state) != VALID_KEY_COMBOS.end();

          // Key dispatching
          constexpr uint32_t MIN_PRESS_DURATION = 100;
          constexpr uint32_t MAX_PRESS_DURATION = 800;
          constexpr uint32_t MIN_HOLD_UP_DOWN_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_ACCESSORY_TOGGLE_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_AUTO_DURATION = 3000;
          constexpr uint32_t MIN_HOLD_SETTING_DURATION = 5000;
          constexpr uint32_t MIN_HOLD_FACTORY_RESET_DURATION = 15000;
          const auto log_press = [](const char* key) {
            ESP_LOGD(minuet::TAG, "Key press: %s", key);
          };
          const auto do_press = [=](uint32_t key_state, uint32_t press_duration) {
            if (press_duration >= MIN_PRESS_DURATION && press_duration <= MAX_PRESS_DURATION) {
              if (key_state == KEY_UP) {
                log_press("KEY_UP");
                do_press_up();
              } else if (key_state == KEY_DOWN) {
                log_press("KEY_DOWN");
                do_press_down();
              } else if (key_state == KEY_RAIN) {
                log_press("KEY_RAIN");
                do_press_rain();
              } else if (key_state == KEY_POWER) {
                log_press("KEY_POWER");
                do_press_power();
              } else if (key_state == KEY_DIRECTION) {
                log_press("KEY_DIRECTION");
                do_press_direction();
              } else if (key_state == KEY_AUTO) {
                log_press("KEY_AUTO");
                do_press_auto();
              } else if (key_state == KEY_4_ON) {
                log_press("KEY_4_ON");
                do_press_4_on();
              } else if (key_state == KEY_4_OFF) {
                log_press("KEY_4_OFF");
                do_press_4_off();
              } else if (key_state == KEY_4_OPEN) {
                log_press("KEY_4_OPEN");
                do_press_4_open();
              } else if (key_state == KEY_4_CLOSE) {
                log_press("KEY_4_CLOSE");
                do_press_4_close();
              } else if (key_state == KEY_COMBO_OPEN_CLOSE) {
                log_press("KEY_COMBO_OPEN_CLOSE");
                do_press_open_close();
              } else if (key_state == KEY_COMBO_AUTO_UP) {
                log_press("KEY_COMBO_AUTO_UP");
                do_press_auto_up();
              } else if (key_state == KEY_COMBO_AUTO_DOWN) {
                log_press("KEY_COMBO_AUTO_DOWN");
                do_press_auto_down();
              } else if (key_state == KEY_COMBO_AUTO_DIRECTION) {
                log_press("KEY_COMBO_AUTO_DIRECTION");
                do_press_auto_direction();
              } else if (key_state == KEY_COMBO_AUTO_POWER) {
                log_press("KEY_COMBO_AUTO_POWER");
                do_press_auto_power();
              } else if (key_state == KEY_COMBO_DIRECTION_UP) {
                log_press("KEY_COMBO_DIRECTION_UP");
                do_press_accessory_up();
              } else if (key_state == KEY_COMBO_DIRECTION_DOWN) {
                log_press("KEY_COMBO_DIRECTION_DOWN");
                do_press_accessory_down();
              }
            }
          };
          const auto log_hold = [](const char* key) {
            ESP_LOGD(minuet::TAG, "Key hold: %s", key);
          };
          const auto do_hold = [=](uint32_t key_state, uint32_t hold_duration) -> bool {
            if (key_state == KEY_UP && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              log_hold("KEY_UP");
              return do_hold_up();
            } else if (key_state == KEY_DOWN && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              log_hold("KEY_DOWN");
              return do_hold_down();
            } else if (key_state == KEY_DIRECTION && hold_duration >= MIN_HOLD_ACCESSORY_TOGGLE_DURATION) {
              log_hold("KEY_DIRECTION");
              return do_hold_accessory_toggle();
            } else if (key_state == KEY_AUTO && hold_duration >= MIN_HOLD_AUTO_DURATION) {
              log_hold("KEY_AUTO");
              return do_hold_auto();
            } else if (key_state == KEY_COMBO_AUTO_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_AUTO_UP");
              return do_hold_use_enhanced_controls();
            } else if (key_state == KEY_COMBO_AUTO_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_AUTO_DOWN");
              return do_hold_use_standard_controls();
            } else if (key_state == KEY_COMBO_POWER_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_POWER_DOWN");
              return do_hold_wifi_toggle();
            } else if (key_state == KEY_COMBO_POWER_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              log_hold("KEY_COMBO_POWER_UP");
              return do_hold_power_on_behavior_toggle();
            } else if (key_state == KEY_POWER && hold_duration >= MIN_HOLD_FACTORY_RESET_DURATION) {
              log_hold("KEY_POWER");
              return do_hold_factory_reset();
            }
            return false;
          };

          // Detect key presses
          auto& last_key_state = id(minuet_keypad_last_key_state);
          auto& last_key_valid = id(minuet_keypad_last_key_valid);
          auto& last_key_time = id(minuet_keypad_last_key_time);
          if (key_state == 0 && last_key_valid) {
            // A key was released
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
          } else if (key_valid && last_key_state == 0) {
            // A key was pressed on its own
            last_key_time = millis();
          } else if (key_valid && key_state != last_key_state && key_state == (key_state | last_key_state)) {
            // A key was pressed that adds to a previously pressed key to form a combo
            last_key_time = millis();
          } else if (key_valid && last_key_valid && key_state == last_key_state) {
            // A key is being held
            const uint32_t hold_duration = millis() - last_key_time;
            if (do_hold(key_state, hold_duration)) {
              key_valid = false; // cancel further processing of this key
            }
          } else if (key_valid && key_state == KEY_AUTO && last_key_valid && (last_key_state & KEY_AUTO) != 0) {
            // A key that was previously combined with auto has been released while auto remains held
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
            key_valid = false; // cancel processing of the modifier itself
          } else if (key_valid && key_state == KEY_DIRECTION && last_key_valid && (last_key_state & KEY_DIRECTION) != 0) {
            // A key that was previously combined with direction has been released while direction remains held
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
            key_valid = false; // cancel processing of the modifier itself
          } else if (key_valid) {
            // A different key is pressed now than was pressed before and does not form a valid combo sequence
            key_valid = false; // cancel further processing of this key
          }
          last_key_state = key_state;
          last_key_valid = key_valid;
    - interval: 300ms
      then:
        - lambda: |-
            bool& state = id(minuet_keypad_auto_indicator_state);
            if (id(minuet_thermostat).mode == CLIMATE_MODE_OFF) {
              state = false;
            } else if (id(minuet_thermostat_override)) {
              state = !state;
            } else {
              state = true;
            }
            id(minuet_keypad_auto_indicator).set_state(state);
        - lambda: |-
            bool& state = id(minuet_keypad_rain_indicator_state);
            if (!id(minuet_rain_sensor_should_stop_fan).state) {
              state = true;
            } else if (id(minuet_rain_sensor_did_stop_fan).state) {
              state = !state;
            } else {
              state = false;
            }
            id(minuet_keypad_rain_indicator).set_state(state);


# Infrared remote control
minuet_ir_control:
  globals:
    - id: minuet_ir_control_accessory_nec # Injected from accessories
      type: void(*)(esphome::remote_base::NECData)
      restore_value: false
      initial_value: "nullptr"
  maxxfan_protocol:
  remote_receiver:
    - id: minuet_ir
      pin:
        number: 2
        mode: input
        inverted: true
        ignore_strapping_warning: true
      dump: [ maxxfan, nec ]
      on_maxxfan:
        then:
          lambda: |-
            auto& cover = id(minuet_cover);
            auto& fan = id(minuet_fan);
            auto& therm = id(minuet_thermostat);
            if (x.auto_mode) {
              fan->make_call()
                  .set_direction(minuet::fan_direction(x.fan_exhaust))
                  .perform();
              id(minuet_thermostat_fan_direction).make_call().set_index(0).perform();
              therm->make_call()
                  .set_mode(CLIMATE_MODE_COOL)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              id(minuet_thermostat_reset_override).execute();
            } else {
              therm->make_call()
                  .set_mode(CLIMATE_MODE_OFF)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              const bool fan_changing_states = fan->state != x.fan_on;
              id(minuet_fan_set).execute(x.fan_on, x.fan_speed / 10, x.fan_exhaust,
                  /*suppress_cover_movement*/ true, /*force*/ false);
              id(minuet_cover_set).execute(x.cover_open, fan_changing_states);
            }
            id(minuet_tone)->execute(x.warn ? "ir_warn" : "ir_confirm");
      on_nec:
        then:
          lambda: |-
            const auto& fn = id(minuet_ir_control_accessory_nec);
            if (!!fn) fn(x);


# Fan controller
#
# FanDirection::REVERSE is air out / exhaust
# FanDirection::FORWARD is air in / intake
minuet_fan_controller:
  globals:
    - id: minuet_fan_suppress_cover_movement
      type: bool
      restore_value: false
      initial_value: "false"
  fan:
    - id: minuet_fan
      name: "Fan"
      platform: template
      has_direction: true
      speed_count: 10
      restore_mode: NO_RESTORE
      on_turn_on:
        then:
          - lambda: |-
              if (!id(minuet_fan_suppress_cover_movement)) {
                id(minuet_cover).make_call().set_command_open().perform();
              }
      on_turn_off:
        then:
          - lambda: |-
              if (!id(minuet_fan_suppress_cover_movement)) {
                id(minuet_cover).make_call().set_command_close().perform();
              }
      on_state:
        then:
          - lambda: |-
              if (!minuet::is_transient_operation()) {
                id(minuet_snapshot_fan_persistent_state).execute();
                const auto& fan = id(minuet_fan);
                id(minuet_thermostat_reconcile_fan_manual_state_change)->execute(fan->state, fan->speed, minuet::fan_direction_is_exhaust(fan->direction));
              }
          - script.execute: minuet_fan_control_update
  switch:
    - id: minuet_fan_override
      name: "Fan Override"
      icon: mdi:bug-outline
      platform: template
      restore_mode: DISABLED
      optimistic: true
      entity_category: config
      disabled_by_default: true
      on_turn_on:
        then:
          - script.execute: minuet_fan_control_update
      on_turn_off:
        then:
          - script.execute: minuet_fan_control_update
  number:
    - id: minuet_fan_override_speed
      name: "Fan Override Speed"
      icon: mdi:square-wave
      unit_of_measurement: 'rpm'
      entity_category: config
      disabled_by_default: true
      platform: template
      min_value: 0
      max_value: 2000 # equal to MAX_SPEED_RPM
      step: 10
      mode: slider
      optimistic: true
      initial_value: 0
      restore_value: false
      on_value:
        then:
          - script.execute: minuet_fan_control_update
  select:
    - id: minuet_fan_override_direction
      platform: template
      name: "Fan Override Direction"
      entity_category: config
      disabled_by_default: true
      optimistic: true
      restore_value: false
      options:
        - Exhaust
        - Intake
      on_value:
        then:
          - script.execute: minuet_fan_control_update
  script:
    - id: minuet_fan_set
      parameters:
        state: bool
        speed: int
        exhaust: bool
        suppress_cover_movement: bool
        force: bool
      then:
        - lambda: |-
            auto& fan = id(minuet_fan);
            if (force || fan->state != state || fan->speed != speed || fan->direction != minuet::fan_direction(exhaust)) {
              id(minuet_fan_suppress_cover_movement) = suppress_cover_movement;
              fan->make_call()
                  .set_state(state)
                  .set_speed(speed)
                  .set_direction(minuet::fan_direction(exhaust))
                  .perform();
              id(minuet_fan_suppress_cover_movement) = false;
            }
    - id: minuet_fan_control_update
      then:
        - lambda: |-
            const auto& fan = id(minuet_fan);
            float speed_rpm;
            bool exhaust;
            if (id(minuet_fan_override).state) {
              speed_rpm = id(minuet_fan).state ? id(minuet_fan_override_speed).state : 0;
              exhaust = id(minuet_fan_override_direction).active_index() == 0;
            } else {
              speed_rpm = id(minuet_fan).state ? minuet::fan_motor::control.get_fan_speed_by_index(fan->speed) : 0;
              exhaust = minuet::fan_direction_is_exhaust(fan->direction);
            }
            minuet::fan_motor::control.set_state(speed_rpm, exhaust);


# Cover controller
minuet_cover_controller:
  globals:
    - id: minuet_cover_movement_interrupted
      type: bool
      restore_value: false
      initial_value: "false"
  cover:
    - id: minuet_cover
      name: "Cover"
      device_class: damper
      platform: template
      optimistic: false
      assumed_state: true
      restore_mode: NO_RESTORE
      open_action:
        then:
          - lambda: |-
              if (id(minuet_cover).current_operation != COVER_OPERATION_OPENING) {
                id(minuet_cover_perform_operation).execute(true);
              }
      close_action:
        then:
          - lambda: |-
              if (id(minuet_cover).current_operation != COVER_OPERATION_CLOSING) {
                id(minuet_cover_perform_operation).execute(false);
              }
      toggle_action:
        then:
          - lambda: |-
              id(minuet_cover_set).execute(id(minuet_cover).is_fully_closed(), /*force*/ false);
  script:
    - id: minuet_cover_set
      parameters:
        open: bool
        force: bool
      then:
        - lambda: |-
            auto& cover = id(minuet_cover);
            if (open && (force || !minuet::cover_is_open_or_opening(cover))) {
              id(minuet_cover).make_call().set_command_open().perform();
            } else if (!open && (force || minuet::cover_is_open_or_opening(cover))) {
              id(minuet_cover).make_call().set_command_close().perform();
            }
    - id: minuet_cover_perform_operation
      mode: restart
      parameters:
        open: bool
      then:
        # Stop the motor first in case the previous operation was interrupted
        - lambda: |-
            id(minuet_cover_motor_sleep).turn_on();

            const auto& current_op = id(minuet_cover).current_operation;
            id(minuet_cover_movement_interrupted) =
                current_op == COVER_OPERATION_OPENING || current_op == COVER_OPERATION_CLOSING;

            id(minuet_cover).current_operation = open ? COVER_OPERATION_OPENING : COVER_OPERATION_CLOSING;
            id(minuet_cover).publish_state();

            if (!minuet::is_transient_operation()) {
              id(minuet_snapshot_cover_persistent_state).execute();
              id(minuet_thermostat_reconcile_cover_manual_state_change)->execute(open);
            }
        # Allow the motor's inertia to settle to avoid prematurely triggering a fault
        # when abruptly changing directions
        - if:
            condition:
              - lambda: 'return id(minuet_cover_movement_interrupted);'
            then:
              - logger.log: "Cover movement was interrupted, waiting for inertia to settle before changing directions"
              - delay: 2s
        # Start the motor
        - lambda: |-
            id(minuet_cover_motor_open).set_state(open);
            id(minuet_cover_motor_sleep).turn_off();
        # Wait for the motor to stall at end of travel or for a timeout to expire
        - wait_until:
            condition:
              binary_sensor.is_on: minuet_cover_motor_fault
            timeout: 6s
        # Stop the motor and report completion
        - lambda: |-
            id(minuet_cover_motor_sleep).turn_on();

            id(minuet_cover).current_operation = COVER_OPERATION_IDLE;
            id(minuet_cover).position = open ? COVER_OPEN : COVER_CLOSED;
            id(minuet_cover).publish_state();


# Thermostat controller
#
# Both the user and the thermostat can modify the state of the same fan and cover entities.
# To resolve this conflict, the thermostat sets the transient flag whenever it changes the state so
# that the fan and cover state change handlers can distinguish whether a given change was initiated
# by the user or by the thermostat.  Only changes made by the user are ever saved to flash.
# When the thermostat is disabled, it turns the fan off but restores the user's last commanded
# speed and direction.
#
# When using standard controls, the keypad forbids the user from changing the fan speed
# or cover position while the thermostat is enabled (because that's what the original firmware
# does).  However, the ESPHome API has no such constraints so if a manual change occurs
# through that interface then the thermostat is disabled to reconcile who's in charge.
#
# When using enhanced controls, the keypad allows the user to take control by incrementally
# modifying whatever state to which the thermostat last set the fan and cover.  The thermostat
# remains enabled but ignored until the override flag is reset.  The same behavior applies
# to changes intiated by the ESPHome API.
#
# This design was chosen so that the fan and cover entities always reflect the true
# state of the device (insofar as it knows) and it ensures a smooth handoff of control back
# to the user when the thermostat is disabled or overridden.
minuet_thermostat:
  substitutions:
    minuet_thermostat_default_temperature: "78"
  globals:
    - id: minuet_thermostat_override
      type: bool
      restore_value: true
      initial_value: "false"
    - id: minuet_thermostat_auto_fan_speed
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_thermostat_auto_fan_exhaust
      type: bool
      restore_value: false
      initial_value: "true"
    - id: minuet_thermostat_auto_cover_open
      type: bool
      restore_value: false
      initial_value: "false"
  select:
    - id: minuet_controls
      platform: template
      name: "Controls"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Standard
        - Enhanced
      on_value:
        then:
          - lambda: |-
              if (i == 0) {
                // Reset some settings that can't be changed with the keypad using standard controls
                // although they can still be controlled via the ESPHome web app and API
                id(minuet_thermostat).make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform();
                id(minuet_thermostat_fan_direction).make_call().select_first().perform();
                id(minuet_thermostat_reset_override).execute();
              }
    - id: minuet_thermostat_fan_direction
      platform: template
      name: "Thermostat Fan Direction"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Same as manual
        - Air out
        - Air in
      on_value:
        then:
          - script.execute: minuet_thermostat_update
  climate:
    - id: minuet_thermostat
      name: "Thermostat"
      icon: mdi:thermostat-auto
      platform: thermostat
      sensor: minuet_ambient_temperature
      visual: # The IR remote uses Fahrenheit natively and expects the fan to do so as well
        min_temperature: 29Â°F
        max_temperature: 99Â°F
        temperature_step: 1Â°F
      cool_overrun: 2Â°F
      cool_deadband: 1Â°F
      min_idle_time: 0s
      min_cooling_off_time: 0s
      min_cooling_run_time: 0s
      min_fan_mode_switching_time: 0s
      idle_action:
        then:
          - script.execute: minuet_thermostat_update
      cool_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_auto_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_off_action:
        then:
          - script.execute: minuet_thermostat_update
      off_mode:
        then:
          - lambda: |-
              id(minuet_thermostat_reset_override).execute();
              if (!minuet::is_transient_operation()) {
                // When the user turns off the thermostat, turn the fan off but restore its
                // last commanded speed and direction.
                const auto& state = minuet::persistent_state();
                id(minuet_fan_set).execute(false, state.fan_speed, state.fan_exhaust,
                      /*suppress_cover_movement*/ false, /*force*/ false);
              }
      on_state:
        then:
          - script.execute: minuet_thermostat_update
      preset:
        - name: 'NONE'
          mode: 'off'
          fan_mode: 'auto'
          default_target_temperature_high: ${minuet_thermostat_default_temperature} Â°F
      default_preset: 'NONE'
      on_boot_restore_from: memory
  switch:
    - id: minuet_thermostat_override_switch
      name: "Thermostat Manual Override"
      icon: mdi:thermostat
      platform: template
      restore_mode: DISABLED
      lambda: 'return id(minuet_thermostat_override);'
      turn_on_action:
        then:
          - script.execute: minuet_thermostat_maybe_set_override
      turn_off_action:
        then:
          - script.execute: minuet_thermostat_reset_override
  script:
    - id: minuet_thermostat_reconcile_fan_manual_state_change
      parameters:
        fan_state: bool
        fan_speed: int
        fan_exhaust: bool
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_fan_speed) != (fan_state ? fan_speed : 0)
                || (id(minuet_thermostat_auto_fan_exhaust) != fan_exhaust
                    && id(minuet_thermostat_fan_direction).active_index() != 0)) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_reconcile_cover_manual_state_change
      parameters:
        cover_open: bool
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_cover_open) != cover_open) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_maybe_set_override
      then:
        - lambda: |-
            if (id(minuet_thermostat).mode != CLIMATE_MODE_OFF && !id(minuet_thermostat_override)) {
              if (id(minuet_controls).active_index() == 1 /*Enhanced*/) {
                // With enhanced controls, activate override mode
                ESP_LOGD(minuet::TAG, "Manual state change while thermostat enabled: engaging override");
                id(minuet_snapshot_fan_persistent_state).execute();
                id(minuet_snapshot_cover_persistent_state).execute();
                id(minuet_thermostat_override) = true;
                id(minuet_thermostat_update).execute();
              } else {
                // With standard controls, override mode isn't supported so turn off the thermostat
                // and leave the fan running in whatever state the user just tried to set it to
                // which is similar to how overriding behaves
                ESP_LOGD(minuet::TAG, "Manual state change while thermostat enabled: disabling thermostat");
                minuet::perform_transient_operation([] {
                  id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
                });
              }
            }
    - id: minuet_thermostat_reset_override
      then:
        - lambda: |-
            id(minuet_thermostat_override) = false;
            id(minuet_thermostat_update).execute();
    - id: minuet_thermostat_update
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (therm->mode != CLIMATE_MODE_OFF && !id(minuet_thermostat_override)) {
              auto& auto_fan_speed = id(minuet_thermostat_auto_fan_speed);
              auto& auto_fan_exhaust = id(minuet_thermostat_auto_fan_exhaust);
              auto& auto_cover_open = id(minuet_thermostat_auto_cover_open);
              if (id(minuet_thermostat).action == CLIMATE_ACTION_COOLING) {
                //const float ambient_temperature = therm->current_temperature;
                //const float target_temperature = therm->target_temperature_high;
                const auto& fan_mode = therm->fan_mode;
                auto_fan_speed = fan_mode == CLIMATE_FAN_AUTO ? 3 : 0; // TODO: choose a speed automatically
                auto_cover_open = true;
              } else {
                auto_fan_speed = 0;
                auto_cover_open = false;
              }
              const auto& state = minuet::persistent_state();
              const auto& direction_index = id(minuet_thermostat_fan_direction).active_index();
              auto_fan_exhaust = direction_index == 1 ? true :
                  direction_index == 2 ? false : state.fan_exhaust;

              minuet::perform_transient_operation([=] {
                id(minuet_fan_set).execute(
                    auto_fan_speed != 0,
                    auto_fan_speed != 0 ? auto_fan_speed : state.fan_speed,
                    auto_fan_speed != 0 ? auto_fan_exhaust : state.fan_exhaust,
                    /*suppress_cover_movement*/ true, /*force*/ false);
                id(minuet_cover_set).execute(auto_cover_open, /*force*/ false);
              });
            }


# Save state to preserve the user's intention when turning the fan off or after a restart.
# The state is not updated by transient operations.
minuet_persistence:
  globals:
    - id: minuet_persistent_state_raw
      type: uint8_t # actually holds minuet::PersistentState
      restore_value: true
      initial_value: "minuet::PersistentState{}.to_storage()"
  select:
    - id: minuet_power_on_behavior
      platform: template
      name: "Power On Behavior"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - "Off"
        - "Restore"
  script:
    - id: minuet_snapshot_fan_persistent_state
      then:
        - lambda: |-
            const auto& fan = id(minuet_fan);
            auto& state = minuet::persistent_state();
            state.fan_on = fan->state;
            state.fan_speed = fan->speed;
            state.fan_exhaust = minuet::fan_direction_is_exhaust(fan->direction);
    - id: minuet_snapshot_cover_persistent_state
      then:
        - lambda: |-
            const auto& cover = id(minuet_cover);
            auto& state = minuet::persistent_state();
            state.cover_open = minuet::cover_is_open_or_opening(cover);
  esphome:
    on_boot:
      - priority: 1000
        then:
          - lambda: |-
              // Prevent the thermostat off_mode handler from overwriting the persistent state
              // of the fan prior to restoration on boot
              minuet::transient_operation_depth++;
      - priority: 500
        then:
          - lambda: |-
              minuet::transient_operation_depth--;

              // Revert to defaults if not restoring persistent state
              const auto& behavior = id(minuet_power_on_behavior).active_index();
              if (!behavior.has_value() || behavior == 0) {
                minuet::persistent_state() = minuet::PersistentState{};
                minuet::perform_transient_operation([] {
                  id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
                });
              }

              // Restore persistent state
              minuet::perform_transient_operation([] {
                const auto& state = minuet::persistent_state();
                id(minuet_fan_set).execute(state.fan_on, state.fan_speed, state.fan_exhaust,
                      /*suppress_cover_movement*/ true, /*force*/ true);
                id(minuet_cover_set).execute(state.cover_open, /*force*/ true);
              });

              // Apply thermostat updates
              id(minuet_thermostat_update).execute();


# Shutdown behavior: Turn off the motors before ESPHome restarts, just in case.
minuet_shutdown:
  esphome:
    on_shutdown:
      - priority: 500
        then:
          - lambda: |-
              minuet::fan_motor::control.shutdown();
              id(minuet_cover_motor_sleep).turn_on();
