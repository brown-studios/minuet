# MINUET CORE PACKAGE
# SUPPORTED HARDWARE: Minuet v2.1
#
# ESPHome package for the Minuet fan controller built-in components.
#
# Include the contents of this file into your device configuration YAML
# file as a package like this (recommended):
#
# packages:
#   <<: !include minuet/core.yaml
#
# The fan controller makes use of most of the GPIO pins for controlling the
# motors and the keypad. Please take care when making modifications to this
# file to prevent malfunction.
#
# To expand the capabilities of your Minuet fan controller, you may attach
# additional components to the I2C bus using the QWIIC connection and
# use GPIO0, GPIO1, GPIO20 (RXD), GPIO21 (TXD) which are presented at the
# GPIO expansion port for accessories.
minuet_components:
  # Include external ESPHome components
  external_components:
    - source: github://j9brown/esphome-maxxfan-protocol@main
      components: [ maxxfan_protocol ]
      refresh: 1min

  # Configure the board
  esp32:
    board: esp32-c3-devkitm-1
    framework:
      type: esp-idf

  # The I2C bus is used by built-in components and is presented via a
  # QWIIC connector on the board edge for accessories
  i2c:
    - id: minuet_i2c
      scl: 6
      sda: 7
      scan: true
      frequency: 100kHz

  # The built-in TCA9555 provides additional 16 GPIO pins, all of which are
  # used by built-in functions. If you need more GPIO pins, you can attach another
  # GPIO expander via the QWIIC port, taking care to assign it an unused I2C address.
  pca9554:
    - id: minuet_xio
      i2c_id: minuet_i2c
      address: 0x20
      pin_count: 16

# Vent fan motor driver
minuet_fan_motor_driver:
  substitutions:
    minuet_fan_motor_pwm_frequency_default: "24000"
  binary_sensor:
    - id: minuet_fan_motor_fault
      name: "Vent Fan Stalled"
      icon: mdi:fan-alert
      device_class: problem
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 13
        mode: input
        inverted: true
      publish_initial_state: true
      filters:
        - delayed_on_off: 0.5s
  sensor:
    - id: minuet_fan_motor_tach
      name: "Vent Fan Tachometer"
      icon: mdi:fan
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: rpm
      accuracy_decimals: 0
      platform: pulse_counter
      pin:
        number: 8
        mode: input
        ignore_strapping_warning: true
      count_mode:
        rising_edge: DISABLE
        falling_edge: INCREMENT
      update_interval: 5s
      filters:
        # The tachometer ticks with each hall sensor pulse (3 times per complete cycle)
        # and the motor has 4 poles so it takes two cycles to rotate completely.
        # Thus we divide the pulses by 6 to obtain the motor shaft speed.
        - multiply: 0.1667
        - round_to_multiple_of: 10
        - delta: 20
  output:
    - id: minuet_fan_motor_sleep
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 14
        mode: output
        inverted: true
    - id: minuet_fan_motor_duty_cycle
      platform: ledc
      pin:
        number: 5
        mode: output
        inverted: false
      channel: 5
      frequency: ${minuet_fan_motor_pwm_frequency_default} Hz
    - id: minuet_fan_motor_forward
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 12
        mode: output
        inverted: false
  number:
    - id: minuet_fan_motor_pwm_frequency
      name: "Fan Motor PWM Frequency"
      icon: mdi:square-wave
      unit_of_measurement: Hz
      device_class: frequency
      entity_category: config
      disabled_by_default: true
      platform: template
      min_value: 1000
      max_value: 60000
      step: 1
      mode: box
      optimistic: true
      initial_value: ${minuet_fan_motor_pwm_frequency_default}
      restore_value: false
      set_action:
        then:
          - lambda: |-
              id(minuet_fan_motor_duty_cycle).update_frequency(x);
  select:
    - id: minuet_fan_motor_type
      platform: template
      name: "Fan Motor Type"
      entity_category: config
      disabled_by_default: true
      optimistic: true
      restore_value: true
      options:
        - "Brushless (3 phase)"
        - "Brushed (1 phase)"

# Vent cover motor driver
minuet_cover_motor_driver:
  binary_sensor:
    - id: minuet_cover_motor_fault
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 9
        mode: input
        inverted: true
      publish_initial_state: true
  output:
    - id: minuet_cover_motor_sleep
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 10
        mode: output
        inverted: true
    - id: minuet_cover_motor_open
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 11
        mode: output
        inverted: false

# Ambient temperature sensor
minuet_ambient_temperature_sensor:
  sensor:
    - id: minuet_thermistor_voltage
      platform: adc
      pin: 4
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 20
            send_every: 10
            send_first_at: 10
      update_interval: never
    - id: minuet_thermistor_resistance
      platform: resistance
      sensor: minuet_thermistor_voltage
      configuration: DOWNSTREAM
      resistor: 10kOhm
    - id: minuet_ambient_temperature
      platform: ntc
      sensor: minuet_thermistor_resistance
      calibration:
        b_constant: 3950
        reference_temperature: 25Â°C
        reference_resistance: 10kOhm
      accuracy_decimals: 1
      filters:
        - round_to_multiple_of: 0.2
  output:
    - id: minuet_thermistor_power
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 15
        mode: output
        inverted: false
  interval:
    - interval: 0.5s
      then:
        lambda: |-
          id(minuet_thermistor_power).turn_on();
          id(minuet_thermistor_voltage).update();
          id(minuet_thermistor_power).turn_off();

# Battery monitor
minuet_battery_monitor:
  binary_sensor:
    - id: minuet_battery_problem
      name: "Battery Problem"
      device_class: problem
      entity_category: diagnostic
      platform: template
  sensor:
    - id: minuet_battery_voltage
      name: "Battery Voltage"
      icon: mdi:car-battery
      device_class: voltage
      state_class: measurement
      entity_category: diagnostic
      unit_of_measurement: V
      accuracy_decimals: 1
      platform: adc
      pin: 3
      attenuation: 12db
      filters:
        - sliding_window_moving_average:
            window_size: 20
            send_every: 10
            send_first_at: 10
        - multiply: 11
        - round_to_multiple_of: 0.2
      update_interval: 0.5s
      on_value:
        then:
          - lambda: |-
              auto& problem = id(minuet_battery_problem);
              const float hysteresis = problem->state ? 0.4f : 0.f;
              const bool low = x < id(minuet_battery_voltage_low).state + hysteresis;
              const bool high = x > id(minuet_battery_voltage_high).state - hysteresis;
              problem->publish_state(low || high);
  number:
    - id: minuet_battery_voltage_low
      name: "Low Battery Voltage Threshold"
      icon: mdi:battery-alert
      entity_category: config
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 10.8
    - id: minuet_battery_voltage_high
      name: "High Battery Voltage Threshold"
      icon: mdi:battery-alert
      entity_category: config
      unit_of_measurement: V
      mode: box
      platform: template
      optimistic: true
      min_value: 9
      max_value: 16
      step: 0.2
      restore_value: true
      initial_value: 15.2

# Rain sensor
minuet_rain_sensor:
  binary_sensor:
    - id: minuet_rain
      name: "Rain Detected"
      icon: mdi:weather-rainy
      device_class: moisture
      entity_category: diagnostic
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 8
        mode: input
        inverted: true
      publish_initial_state: true
      filters:
        - delayed_on_off:
            time_on: 2s
            time_off: 60s
      on_press:
        then:
          - lambda: |-
              if (id(minuet_fan).state && id(minuet_rain_sensor_should_stop_fan).state) {
                id(minuet_rain_sensor_did_stop_fan).publish_state(true);
                id(minuet_fan).make_call().set_state(false).perform();
              }
    - id: minuet_rain_sensor_did_stop_fan
      name: "Rain Stopped Fan"
      device_class: problem
      entity_category: diagnostic
      platform: template
  switch:
    - id: minuet_rain_sensor_should_stop_fan
      name: "Stop Fan When Rain Detected"
      icon: mdi:weather-rainy
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_turn_off:
        then:
          - binary_sensor.template.publish:
              id: minuet_rain_sensor_did_stop_fan
              state: OFF
  button:
    - id: minuet_rain_sensor_reset
      name: "Reset Rain Sensor"
      icon: mdi:weather-rainy
      platform: template
      on_press:
        then:
          - binary_sensor.template.publish:
              id: minuet_rain_sensor_did_stop_fan
              state: OFF
          - switch.turn_on: minuet_rain_sensor_should_stop_fan

# Provides audible feedback
minuet_tone:
  substitutions:
    # Tones specified in the RTTTL language
    # Tones whose names start with '!' are important and cannot be suppressed
    #
    # Design guidelines:
    # - Tones start on E6
    # - Incrementing a value rises to G6
    # - Decrementing a value falls to C6
    # - Enabling a feature rises to A6
    # - Disabling a feature falls to A5
    # - Resetting a feature is a turn of E6, F6, E6, D6, E6
    # - Play tones only for actions whose effect cannot be immediately observed
    #   such as changing the thermostat temperature and don't play tones for actions
    #   whose effect can be immediately observed such as changing the fan speed
    # - Of course, if you're customizing this firmware you can change the tones to
    #   anything you like!
    #
    # Useful tool for testing tones: https://adamonsoon.github.io/rtttl-play/
    minuet_tones: |-
      // Generic tones
      "beep:d=16,o=4,b=144:e6",
      "!urgent:d=16,o=4,b=144:32e6,32p,e6",
      "minuet:d=4,o=4,b=152:d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,f#4,8g4,8a4,8b4,8g4,32b4,2a4.,d5,8g4,8a4,8b4,8c5,d5,g4,g4,e5,32c5,32b4,16c5,8d5,8e5,8f#5,g5,g4,g4,32c5,32b4,16c5,8d5,8c5,8b4,8a4,b4,8c5,8b4,8a4,8g4,a4,8b4,8a4,8g4,8f#4,2g4.",
      // Specific actions
      "manual_fan_on:",
      "manual_fan_off:",
      "manual_speed_up:",
      "manual_speed_down:",
      "manual_dir_in:",
      "manual_dir_out:",
      "manual_cover_open:",
      "manual_cover_close:",
      "auto_on:",
      "auto_off:",
      "auto_temp_up:d=16,o=4,b=144:e6,g6",
      "auto_temp_down:d=16,o=4,b=144:e6,c6",
      "auto_temp_default:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6",
      "auto_fan_on:d=16,o=4,b=144:e6,p,8a6",
      "auto_fan_off:d=16,o=4,b=144:e6,p,8a5",
      "auto_dir_in:d=16,o=4,b=144:32e6,32d6,8c6",
      "auto_dir_out:d=16,o=4,b=144:32e6,32f6,8g6",
      "auto_dir_same:d=16,o=4,b=144:32e6,32p,8e6",
      "rain_on:",
      "rain_off:",
      "ir_confirm:",
      "ir_warn:d=16,o=4,b=144:32e6,32p,e6",
      "!controls_enhanced:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a6",
      "!controls_standard:d=16,o=4,b=144:32e6,32p,32e6,32p,32e6,32p,8a5",
      "!wifi_on:d=16,o=4,b=144:32e6,32p,32e6,32p,8a6",
      "!wifi_off:d=16,o=4,b=144:32e6,32p,32e6,32p,8a5",
      "!power_on_restore:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a6",
      "!power_on_default:d=16,o=4,b=144:32e6,32f6,32e6,32d6,8e6,8a5",
      "!factory_reset:d=16,o=4,b=144:8e6,8a5,8e5,4a4",
    minuet_tone_default_if_unknown: "beep"
  output:
    - id: minuet_tone_pwm
      platform: ledc
      pin:
        number: 10
        mode: output
        inverted: false
      channel: 3
  rtttl:
    - id: minuet_tone_generator
      output: minuet_tone_pwm
  switch:
    - id: minuet_tone_enable
      name: "Audible Feedback"
      icon: mdi:volume-high
      entity_category: config
      platform: template
      optimistic: true
      restore_mode: RESTORE_DEFAULT_ON
      on_turn_off:
        then:
          - rtttl.stop:
  api:
    actions:
      - action: play_tone
        variables:
          name: string
        then:
          - lambda: id(minuet_tone)->execute(name);
      - action: play_tone_rtttl
        variables:
          tone: string
        then:
          - lambda: id(minuet_tone_rtttl)->execute(tone);
      - action: stop_tone
        then:
          - rtttl.stop:
  script:
    - id: minuet_tone
      parameters:
        name: string
      then:
        - lambda: |-
            constexpr const char* tones[] = { ${minuet_tones} };
            constexpr const char* default_if_unknown = "${minuet_tone_default_if_unknown}";
            for (;;) {
              for (size_t i = 0; i < sizeof(tones) / sizeof(tones[0]); i++) {
                const char* tone = tones[i];
                char* colon_pos = strchr(tone, ':');
                if (!colon_pos) {
                  ESP_LOGD("minuet", "RTTTL tone missing name: '%s'", tone);
                  continue;
                }
                size_t name_length = colon_pos - tone;
                if (name.size() == name_length && strncmp(name.c_str(), tone, name_length) == 0) {
                  if (colon_pos[1]) { // ensure tone is not empty
                    id(minuet_tone_rtttl)->execute(colon_pos - 1);
                  }
                  return;
                }
              }
              ESP_LOGD("minuet", "RTTTL tone not found: '%s'", name.c_str());
              if (name == default_if_unknown) {
                return;
              }
              name = default_if_unknown;
            }
    - id: minuet_tone_rtttl
      parameters:
        tone: string
      then:
        - lambda: |-
            if (id(minuet_tone_enable).state || tone[0] == '!') {
              id(minuet_tone_generator).play(tone);
            }
  button:
    - id: minuet_beep
      name: Beep
      icon: mdi:alert
      disabled_by_default: true
      entity_category: config
      platform: template
      on_press:
        then:
          - script.execute:
              id: minuet_tone
              name: beep

# Read the keypad controls and determine an action
# Refer to the user guide for the control scheme
minuet_keypad_control:
  globals:
    - id: minuet_keypad_bouncy_key_state
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_bouncy_key_time
      type: uint32_t
      restore_value: false
      initial_value: "millis()"
    - id: minuet_keypad_last_key_state
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_last_key_valid
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_last_key_time
      type: uint32_t
      restore_value: false
      initial_value: "0"
    - id: minuet_keypad_auto_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_rain_indicator_state
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_keypad_wifi_switch # Injected from wifi.yaml
      type: Switch*
      restore_value: false
      initial_value: "nullptr"
    - id: minuet_keypad_accessory_toggle # Injected from accessories
      type: bool(*)()
      restore_value: false
      initial_value: "nullptr"
  button:
    - id: minuet_restart
      platform: restart
      name: Restart
      icon: mdi:restart
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset
      platform: factory_reset
      name: Factory Reset
      icon: mdi:restart-alert
      disabled_by_default: true
      entity_category: config
    - id: minuet_factory_reset_after_delay
      platform: template
      on_press:
        then:
          - delay: 2s
          - button.press: minuet_factory_reset
  output:
    - id: minuet_keypad_auto_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 0
        mode: output
        inverted: true
    - id: minuet_keypad_rain_indicator
      platform: gpio
      pin:
        pca9554: minuet_xio
        number: 1
        mode: output
        inverted: true
  interval:
    - interval: 10ms
      then:
        lambda: |-
          // Determine which menu of keypad actions is active.
          enum class Menu {
            STANDARD_MANUAL, STANDARD_AUTO, ENHANCED,
          };
          const auto which_menu = []() -> Menu {
            if (id(minuet_controls).active_index() == 1 /*Enhanced*/) return Menu::ENHANCED;
            return id(minuet_thermostat).mode == CLIMATE_MODE_OFF ? Menu::STANDARD_MANUAL : Menu::STANDARD_AUTO;
          };

          // Declare all of the possible actions
          // This code might be tidier in separate functions but that would require putting them
          // in a separate header file which is less convenient
          const auto do_press_power = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->turn_off().perform();
                id(minuet_tone)->execute("manual_fan_off");
              } else {
                fan->turn_on().perform();
                id(minuet_tone)->execute("manual_fan_on");
              }
            }
          };
          const auto do_press_4_on = [which_menu]{
            auto& fan = id(minuet_fan);
            if (fan->state) {
              const auto SPEED_CYCLE = { 1, 3, 7, 10, };
              const auto it = std::find_if(SPEED_CYCLE.begin(), SPEED_CYCLE.end(), [](int speed) { return speed > fan->speed; });
              const bool going_up = it != SPEED_CYCLE.end();
              fan->make_call().set_speed(going_up ? *it : *SPEED_CYCLE.begin()).perform();
              id(minuet_tone)->execute(going_up ? "manual_speed_up" : "manual_speed_down");
            } else {
              fan->turn_on().perform();
              id(minuet_tone)->execute("manual_fan_on");
            }
          };
          const auto do_press_4_off = [which_menu]{
            auto& fan = id(minuet_fan);
            fan->turn_off().perform();
            id(minuet_tone)->execute("manual_fan_off");
          };
          const auto do_press_up = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed + 1).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
            }
          };
          const auto do_hold_up = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->get_traits().supported_speed_count()).perform();
                id(minuet_tone)->execute("manual_speed_up");
              }
              return true;
            }
            return false;
          };
          const auto do_press_down = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
                id(minuet_tone)->execute("auto_temp_down");
            } else {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(fan->speed - 1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
            }
          };
          const auto do_hold_down = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& fan = id(minuet_fan);
              if (fan->state) {
                fan->make_call().set_speed(1).perform();
                id(minuet_tone)->execute("manual_speed_down");
              }
              return true;
            }
            return false;
          };
          const auto do_press_open_close = [which_menu]{
            const auto menu = which_menu();
            if (menu != Menu::STANDARD_AUTO) {
              auto& cover = id(minuet_cover);
              if (id(minuet_cover).is_fully_closed()) {
                cover->make_call().set_command_open().perform();
                id(minuet_tone)->execute("manual_cover_open");
              } else {
                cover->make_call().set_command_close().perform();
                id(minuet_tone)->execute("manual_cover_close");
              }
            }
          };
          const auto do_press_4_open = [which_menu]{
            auto& cover = id(minuet_cover);
            cover->make_call().set_command_open().perform();
            id(minuet_tone)->execute("manual_cover_open");
          };
          const auto do_press_4_close = [which_menu]{
            auto& cover = id(minuet_cover);
            cover->make_call().set_command_close().perform();
            id(minuet_tone)->execute("manual_cover_close");
          };
          const auto do_press_direction = [which_menu]{
            auto& fan = id(minuet_fan);
            if (fan->state) {
              if (fan->direction == FanDirection::FORWARD) {
                fan->make_call().set_direction(FanDirection::REVERSE).perform();
                id(minuet_tone)->execute("manual_dir_out");
              } else {
                fan->make_call().set_direction(FanDirection::FORWARD).perform();
                id(minuet_tone)->execute("manual_dir_in");
              }
            }
          };
          const auto do_press_auto = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
              id(minuet_tone)->execute("auto_off");
            } else if (menu == Menu::STANDARD_MANUAL) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
              id(minuet_tone)->execute("auto_on");
            } else {
              auto& therm = id(minuet_thermostat);
              if (therm->mode == CLIMATE_MODE_OFF) {
                therm->make_call().set_mode(CLIMATE_MODE_COOL).perform();
                id(minuet_tone)->execute("auto_on");
              } else if (id(minuet_thermostat_override)) {
                id(minuet_thermostat_reset_override).execute();
                id(minuet_tone)->execute("auto_on");
              } else {
                therm->make_call().set_mode(CLIMATE_MODE_OFF).perform();
                id(minuet_tone)->execute("auto_off");
              }
            }
          };
          const auto do_press_auto_up = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature + 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_up");
            }
          };
          const auto do_press_auto_down = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(therm->target_temperature - 1.f / 1.8f).perform();
              id(minuet_tone)->execute("auto_temp_down");
            }
          };
          const auto do_press_auto_reset = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(fahrenheit_to_celsius(${minuet_thermostat_default_temperature})).perform();
              id(minuet_tone)->execute("auto_temp_default");
            }
          };
          const auto do_press_auto_power = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              auto& therm = id(minuet_thermostat);
              if (therm->fan_mode == CLIMATE_FAN_OFF) {
                therm->make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform();
                id(minuet_tone)->execute("auto_fan_on");
              } else {
                therm->make_call().set_fan_mode(CLIMATE_FAN_OFF).perform();
                id(minuet_tone)->execute("auto_fan_off");
              }
            }
          };
          const auto do_press_auto_direction = [which_menu]{
            const auto menu = which_menu();
            if (menu == Menu::ENHANCED) {
              id(minuet_thermostat_fan_direction).make_call().select_next(true).perform();
              const auto& index = id(minuet_thermostat_fan_direction).active_index();
              id(minuet_tone)->execute(index == 1 ? "auto_dir_out" : index == 2 ? "auto_dir_in" : "auto_dir_same");
            }
          };
          const auto do_hold_auto = [which_menu]() -> bool {
            const auto menu = which_menu();
            if (menu == Menu::STANDARD_AUTO) {
              auto& therm = id(minuet_thermostat);
              therm->make_call().set_target_temperature(fahrenheit_to_celsius(${minuet_thermostat_default_temperature})).perform();
              id(minuet_tone)->execute("auto_temp_default");
              return true;
            }
            return false;
          };
          const auto do_press_rain = [which_menu]{
            if (id(minuet_rain_sensor_did_stop_fan).state || !id(minuet_rain_sensor_should_stop_fan).state) {
              id(minuet_rain_sensor_reset).press();
              id(minuet_tone)->execute("rain_on");
            } else {
              id(minuet_rain_sensor_should_stop_fan).turn_off();
              id(minuet_tone)->execute("rain_off");
            }
          };
          const auto do_hold_use_enhanced_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(1).perform();
            id(minuet_tone)->execute("!controls_enhanced");
            return true;
          };
          const auto do_hold_use_standard_controls = [which_menu]() -> bool {
            id(minuet_controls).make_call().set_index(0).perform();
            id(minuet_tone)->execute("!controls_standard");
            return true;
          };
          const auto do_hold_wifi_toggle = [which_menu]() -> bool {
            const auto& wifi_switch = id(minuet_keypad_wifi_switch);
            if (wifi_switch) {
              wifi_switch->toggle();
              id(minuet_tone)->execute(wifi_switch->state ? "!wifi_on" : "!wifi_off");
              return true;
            }
            return false;
          };
          const auto do_hold_power_on_behavior_toggle = [which_menu]() -> bool {
            auto& behavior = id(minuet_power_on_behavior);
            behavior->make_call().select_next(true).perform();
            id(minuet_tone)->execute(behavior->active_index() == 1 ? "!power_on_restore" : "!power_on_default");
            return true;
          };
          const auto do_hold_factory_reset = [which_menu]() -> bool {
            id(minuet_factory_reset_after_delay).press();
            id(minuet_tone)->execute("!factory_reset");
            return true;
          };
          const auto do_hold_accessory_toggle = [which_menu]() -> bool {
            const auto& fn = id(minuet_keypad_accessory_toggle);
            return !!fn && fn();
          };

          // Scan the keypad matrix
          // All of the pins have internal pull-up resistors
          constexpr uint8_t XIO_PIN_R1 = 5;
          constexpr uint8_t XIO_PIN_R2 = 3;
          constexpr uint8_t XIO_PIN_C1 = 7;
          constexpr uint8_t XIO_PIN_C2 = 4;
          constexpr uint8_t XIO_PIN_C3 = 2;
          constexpr uint8_t XIO_PIN_C4 = 6;
          auto& xio = id(minuet_xio);

          // Read the keypad row pins themselves while they are undriven
          // to detect OPEN and CLOSE on the 4 key keypad
          const bool key_r1_gnd = !xio->digital_read(XIO_PIN_R1);
          const bool key_r2_gnd = !xio->digital_read(XIO_PIN_R2);

          // Drive keypad row 1 low and read the columns
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r1_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r1_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r1_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r1_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R1, gpio::FLAG_INPUT);

          // Drive keypad row 2 low and read the columns
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_OUTPUT);
          xio->loop();
          const bool key_r2_c1 = !xio->digital_read(XIO_PIN_C1);
          const bool key_r2_c2 = !xio->digital_read(XIO_PIN_C2);
          const bool key_r2_c3 = !xio->digital_read(XIO_PIN_C3);
          const bool key_r2_c4 = !xio->digital_read(XIO_PIN_C4);
          xio->pin_mode(XIO_PIN_R2, gpio::FLAG_INPUT);

          // Combine all of the key states into a single value with one bit per key
          // that represents the complete state of the keypad
          constexpr uint32_t KEY_UP = 1u << 0;
          constexpr uint32_t KEY_DOWN = 1u << 1;
          constexpr uint32_t KEY_RAIN = 1u << 2;
          constexpr uint32_t KEY_POWER = 1u << 3;
          constexpr uint32_t KEY_DIRECTION = 1u << 4;
          constexpr uint32_t KEY_AUTO = 1u << 5;
          constexpr uint32_t KEY_4_CLOSE = 1u << 6;
          constexpr uint32_t KEY_4_OPEN = 1u << 7;
          constexpr uint32_t KEY_4_OFF = 1u << 8;
          constexpr uint32_t KEY_4_ON = 1u << 9;
          const uint32_t key_state =
              (key_r1_c2 ? KEY_UP : 0) |
              (key_r1_c3 ? KEY_DOWN : 0) |
              (key_r1_c4 ? KEY_RAIN : 0) |
              (key_r2_c2 ? KEY_POWER : 0) |
              (key_r2_c3 ? KEY_DIRECTION : 0) |
              (key_r2_c4 ? KEY_AUTO : 0) |
              (key_r1_gnd ? KEY_4_CLOSE : 0) |
              (key_r2_gnd ? KEY_4_OPEN : 0) |
              (key_r1_c1 ? KEY_4_OFF : 0) |
              (key_r2_c1 ? KEY_4_ON : 0);

          // Debounce the keys
          constexpr uint32_t DEBOUNCE_DURATION = 40;
          auto& bouncy_key_state = id(minuet_keypad_bouncy_key_state);
          auto& bouncy_key_time = id(minuet_keypad_bouncy_key_time);
          if (key_state != bouncy_key_state) {
            bouncy_key_state = key_state;
            bouncy_key_time = millis();
            return; // wait for key state to be debounced before processing it
          }
          if (millis() - bouncy_key_time < DEBOUNCE_DURATION) {
            return; // wait for key state to be debounced before processing it
          }

          // Check whether this key combination is potentially valid
          constexpr uint32_t KEY_COMBO_OPEN_CLOSE = KEY_UP | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_UP = KEY_AUTO | KEY_UP;
          constexpr uint32_t KEY_COMBO_AUTO_DOWN = KEY_AUTO | KEY_DOWN;
          constexpr uint32_t KEY_COMBO_AUTO_OPEN_CLOSE = KEY_AUTO | KEY_COMBO_OPEN_CLOSE;
          constexpr uint32_t KEY_COMBO_AUTO_DIRECTION = KEY_AUTO | KEY_DIRECTION;
          constexpr uint32_t KEY_COMBO_AUTO_POWER = KEY_AUTO | KEY_POWER;
          constexpr uint32_t KEY_COMBO_POWER_UP = KEY_POWER | KEY_UP;
          constexpr uint32_t KEY_COMBO_POWER_DOWN = KEY_POWER | KEY_DOWN;
          const auto VALID_KEY_COMBOS = {
              KEY_UP, KEY_DOWN, KEY_RAIN, KEY_POWER, KEY_DIRECTION, KEY_AUTO,
              KEY_4_CLOSE, KEY_4_OPEN, KEY_4_OFF, KEY_4_ON,
              KEY_COMBO_OPEN_CLOSE, KEY_COMBO_AUTO_UP, KEY_COMBO_AUTO_DOWN,
              KEY_COMBO_AUTO_OPEN_CLOSE, KEY_COMBO_AUTO_DIRECTION, KEY_COMBO_AUTO_POWER,
              KEY_COMBO_POWER_UP, KEY_COMBO_POWER_DOWN,
          };
          bool key_valid = std::find(VALID_KEY_COMBOS.begin(), VALID_KEY_COMBOS.end(), key_state) != VALID_KEY_COMBOS.end();

          // Key dispatching
          constexpr uint32_t MIN_PRESS_DURATION = 100;
          constexpr uint32_t MAX_PRESS_DURATION = 800;
          constexpr uint32_t MIN_HOLD_UP_DOWN_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_ACCESSORY_TOGGLE_DURATION = 1000;
          constexpr uint32_t MIN_HOLD_AUTO_DURATION = 3000;
          constexpr uint32_t MIN_HOLD_SETTING_DURATION = 5000;
          constexpr uint32_t MIN_HOLD_FACTORY_RESET_DURATION = 15000;
          const auto do_press = [=](uint32_t key_state, uint32_t press_duration) {
            if (press_duration >= MIN_PRESS_DURATION && press_duration <= MAX_PRESS_DURATION) {
              if (key_state == KEY_UP) {
                do_press_up();
              } else if (key_state == KEY_DOWN) {
                do_press_down();
              } else if (key_state == KEY_RAIN) {
                do_press_rain();
              } else if (key_state == KEY_POWER) {
                do_press_power();
              } else if (key_state == KEY_DIRECTION) {
                do_press_direction();
              } else if (key_state == KEY_AUTO) {
                do_press_auto();
              } else if (key_state == KEY_4_ON) {
                do_press_4_on();
              } else if (key_state == KEY_4_OFF) {
                do_press_4_off();
              } else if (key_state == KEY_4_OPEN) {
                do_press_4_open();
              } else if (key_state == KEY_4_CLOSE) {
                do_press_4_close();
              } else if (key_state == KEY_COMBO_OPEN_CLOSE) {
                do_press_open_close();
              } else if (key_state == KEY_COMBO_AUTO_UP) {
                do_press_auto_up();
              } else if (key_state == KEY_COMBO_AUTO_DOWN) {
                do_press_auto_down();
              } else if (key_state == KEY_COMBO_AUTO_OPEN_CLOSE) {
                do_press_auto_reset();
              } else if (key_state == KEY_COMBO_AUTO_DIRECTION) {
                do_press_auto_direction();
              } else if (key_state == KEY_COMBO_AUTO_POWER) {
                do_press_auto_power();
              }
            }
          };
          const auto do_hold = [=](uint32_t key_state, uint32_t hold_duration) -> bool {
            if (key_state == KEY_UP && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              return do_hold_up();
            } else if (key_state == KEY_DOWN && hold_duration >= MIN_HOLD_UP_DOWN_DURATION) {
              return do_hold_down();
            } else if (key_state == KEY_DIRECTION && hold_duration >= MIN_HOLD_ACCESSORY_TOGGLE_DURATION) {
              return do_hold_accessory_toggle();
            } else if (key_state == KEY_AUTO && hold_duration >= MIN_HOLD_AUTO_DURATION) {
              return do_hold_auto();
            } else if (key_state == KEY_COMBO_AUTO_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              return do_hold_use_enhanced_controls();
            } else if (key_state == KEY_COMBO_AUTO_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              return do_hold_use_standard_controls();
            } else if (key_state == KEY_COMBO_POWER_DOWN && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              return do_hold_wifi_toggle();
            } else if (key_state == KEY_COMBO_POWER_UP && hold_duration >= MIN_HOLD_SETTING_DURATION) {
              return do_hold_power_on_behavior_toggle();
            } else if (key_state == KEY_POWER && hold_duration >= MIN_HOLD_FACTORY_RESET_DURATION) {
              return do_hold_factory_reset();
            }
            return false;
          };

          // Detect key presses
          auto& last_key_state = id(minuet_keypad_last_key_state);
          auto& last_key_valid = id(minuet_keypad_last_key_valid);
          auto& last_key_time = id(minuet_keypad_last_key_time);
          if (key_state == 0 && last_key_valid) {
            // A key was released
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
          } else if (key_valid && last_key_state == 0) {
            // A key was pressed on its own
            last_key_time = millis();
          } else if (key_valid && last_key_valid && key_state != last_key_state && key_state == (key_state | last_key_state)) {
            // A key was pressed that adds to a previously pressed key to form a combo
            last_key_time = millis();
          } else if (key_valid && last_key_valid && key_state == last_key_state) {
            // A key is being held
            const uint32_t hold_duration = millis() - last_key_time;
            if (do_hold(key_state, hold_duration)) {
              key_valid = false; // cancel further processing of this key
            }
          } else if (key_valid && key_state == KEY_AUTO && last_key_valid && (last_key_state & KEY_AUTO) != 0) {
            // A key that was previously combined with auto has been released while auto remains held
            const uint32_t press_duration = millis() - last_key_time;
            do_press(last_key_state, press_duration);
          } else if (key_valid) {
            // A different key is pressed now than was pressed before
            key_valid = false; // cancel further processing of this key
          }
          last_key_state = key_state;
          last_key_valid = key_valid;
    - interval: 300ms
      then:
        - lambda: |-
            bool& state = id(minuet_keypad_auto_indicator_state);
            if (id(minuet_thermostat).mode == CLIMATE_MODE_OFF) {
              state = false;
            } else if (id(minuet_thermostat_override)) {
              state = !state;
            } else {
              state = true;
            }
            id(minuet_keypad_auto_indicator).set_state(state);
        - lambda: |-
            bool& state = id(minuet_keypad_rain_indicator_state);
            if (!id(minuet_rain_sensor_should_stop_fan).state) {
              state = true;
            } else if (id(minuet_rain_sensor_did_stop_fan).state) {
              state = !state;
            } else {
              state = false;
            }
            id(minuet_keypad_rain_indicator).set_state(state);

# Infrared remote control
minuet_ir_control:
  maxxfan_protocol:
  remote_receiver:
    - id: minuet_ir
      pin:
        number: 2
        mode: input
        inverted: true
        ignore_strapping_warning: true
      dump: maxxfan
      on_maxxfan:
        then:
          lambda: |-
            auto& cover = id(minuet_cover);
            auto& fan = id(minuet_fan);
            auto& therm = id(minuet_thermostat);
            if (x.auto_mode) {
              fan->make_call()
                  .set_direction(x.fan_exhaust ? FanDirection::REVERSE : FanDirection::FORWARD)
                  .perform();
              id(minuet_thermostat_fan_direction).make_call().set_index(0).perform();
              therm->make_call()
                  .set_mode(CLIMATE_MODE_COOL)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              id(minuet_thermostat_reset_override).execute();
            } else {
              therm->make_call()
                  .set_mode(CLIMATE_MODE_OFF)
                  .set_target_temperature(fahrenheit_to_celsius(x.auto_temperature))
                  .perform();
              const bool fan_changing_states = fan->state != x.fan_on;
              id(minuet_fan_set).execute(x.fan_on, x.fan_speed / 10,
                  x.fan_exhaust ? FanDirection::REVERSE : FanDirection::FORWARD,
                  /*suppress_cover_movement*/ true, /*force*/ false);
              id(minuet_cover_set).execute(x.cover_open, fan_changing_states);
            }
            id(minuet_tone)->execute(x.warn ? "ir_warn" : "ir_confirm");

# Fan controller
#
# FanDirection::REVERSE is air out / exhaust
# FanDirection::FORWARD is air in / intake
minuet_fan_controller:
  substitutions:
    minuet_fan_speed_count: '10'
    minuet_fan_duty_cycle_table: '0.08f, 0.11f, 0.14f, 0.18f, 0.22f, 0.26f, 0.3f, 0.35f, 0.4f, 0.45f'
    #minuet_fan_duty_cycle_table: '0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f, 0.9f, 1.f'
  globals:
    - id: minuet_fan_last_duty_cycle
      type: float
      restore_value: false
      initial_value: "0.f"
    - id: minuet_fan_target_duty_cycle
      type: float
      restore_value: false
      initial_value: "0.f"
    - id: minuet_fan_suppress_cover_movement
      type: bool
      restore_value: false
      initial_value: "false"
    - id: minuet_fan_brushed_motor_last_pulse
      type: uint32_t
      restore_value: false
      initial_value: "false"
  fan:
    - id: minuet_fan
      name: "Vent Fan"
      platform: template
      has_direction: true
      speed_count: ${minuet_fan_speed_count}
      restore_mode: ALWAYS_OFF
      on_turn_on:
        then:
          - lambda: |-
              if (!id(minuet_fan_suppress_cover_movement)) {
                id(minuet_cover).make_call().set_command_open().perform();
              }
      on_turn_off:
        then:
          - lambda: |-
              if (!id(minuet_fan_suppress_cover_movement)) {
                id(minuet_cover).make_call().set_command_close().perform();
              }
      on_state:
        then:
          - lambda: |-
              if (!id(minuet_suppress_manual_state_change)) {
                auto& fan = id(minuet_fan);
                auto& manual = id(minuet_fan_manual_state);
                manual->state = fan->state;
                manual->speed = fan->speed;
                manual->direction = fan->direction;
                manual->publish_state();
                id(minuet_thermostat_reconcile_fan_manual_state_change)->execute(fan->state, fan->speed, fan->direction);
              }
          - lambda: |-
              constexpr size_t SPEED_COUNT = (${minuet_fan_speed_count});
              constexpr float DUTY_CYCLES[SPEED_COUNT] = { ${minuet_fan_duty_cycle_table} };
              const int speed = id(minuet_fan).speed;
              float duty_cycle = 0.f;
              if (id(minuet_fan).state && speed > 0 && speed <= SPEED_COUNT) {
                duty_cycle = DUTY_CYCLES[speed - 1];
                if (id(minuet_fan).direction == FanDirection::REVERSE) {
                  duty_cycle = -duty_cycle;
                }
              }
              id(minuet_fan_target_duty_cycle) = duty_cycle;
  interval:
    - interval: 50ms
      then:
        lambda: |-
          float& last_duty_cycle = id(minuet_fan_last_duty_cycle);
          float& target_duty_cycle = id(minuet_fan_target_duty_cycle);
          if (id(minuet_fan_motor_fault).state) {
            if (target_duty_cycle != 0.f || last_duty_cycle != 0.f) {
              ESP_LOGD("minuet", "Fan stalled, disabling the motor for safety");
              id(minuet_fan_motor_duty_cycle).turn_off();
              id(minuet_fan)->turn_off().perform();
              last_duty_cycle = 0.f;
              target_duty_cycle = 0.f;
            }
          } else if (target_duty_cycle != last_duty_cycle) {
            // Ramp the duty cycle linearly over time up to the desired target.
            constexpr float MAX_RAMP_PER_INTERVAL = 0.01f;
            const float delta = target_duty_cycle - last_duty_cycle;
            if (fabs(delta) < MAX_RAMP_PER_INTERVAL) {
              last_duty_cycle = target_duty_cycle;
            } else {
              last_duty_cycle += copysign(MAX_RAMP_PER_INTERVAL, delta);
            }
            id(minuet_fan_motor_forward).set_state(last_duty_cycle >= 0.f);
            id(minuet_fan_motor_duty_cycle).set_level(fabs(last_duty_cycle));
          }
          if (last_duty_cycle == 0.f && target_duty_cycle == 0.f) {
            id(minuet_fan_motor_sleep).turn_on();
          } else {
            if (id(minuet_fan_motor_type).active_index() == 1) {
              // When operating a brushed motor, occasionally pulse the sleep pin to reset the
              // motor lock timeout and prevent the motor driver from stopping the motor because
              // it doesn't observe any change in the hall sensors.  This is fine for experiments
              // but each pulse makes the motor generate a slight tick as it skips commutation.
              // A better solution would be to use the SPI variant of the MCT8316Z and to program
              // it to disable the motor lock timeout.
              uint32_t now = millis();
              auto& last_pulse = id(minuet_fan_brushed_motor_last_pulse);
              if (now - last_pulse > 500) {
                id(minuet_fan_motor_sleep).turn_on();
                last_pulse = now;
              }
            }
            id(minuet_fan_motor_sleep).turn_off();
          }
  script:
    - id: minuet_fan_set
      parameters:
        state: bool
        speed: int
        direction: FanDirection
        suppress_cover_movement: bool
        force: bool
      then:
        - lambda: |-
            auto& fan = id(minuet_fan);
            if (force || fan->state != state || fan->speed != speed || fan->direction != direction) {
              id(minuet_fan_suppress_cover_movement) = suppress_cover_movement;
              fan->make_call()
                  .set_state(state)
                  .set_speed(speed)
                  .set_direction(direction)
                  .perform();
              id(minuet_fan_suppress_cover_movement) = false;
            }

# Cover controller
minuet_cover_controller:
  cover:
    - id: minuet_cover
      name: "Vent Cover"
      device_class: damper
      platform: template
      optimistic: false
      assumed_state: true
      restore_mode: NO_RESTORE
      open_action:
        then:
          - lambda: |-
              if (!id(minuet_suppress_manual_state_change)) {
                id(minuet_cover_manual_state).make_call().set_command_open().perform();
                id(minuet_thermostat_reconcile_cover_manual_state_change)->execute(/*open*/ true);
              }
              if (id(minuet_cover).current_operation != COVER_OPERATION_OPENING) {
                id(minuet_cover_perform_operation).execute(true);
              }
      close_action:
        then:
          - lambda: |-
              if (!id(minuet_suppress_manual_state_change)) {
                id(minuet_cover_manual_state).make_call().set_command_close().perform();
                id(minuet_thermostat_reconcile_cover_manual_state_change)->execute(/*open*/ false);
              }
              if (id(minuet_cover).current_operation != COVER_OPERATION_CLOSING) {
                id(minuet_cover_perform_operation).execute(false);
              }
      toggle_action:
        then:
          - lambda: |-
              id(minuet_cover_set).execute(id(minuet_cover).is_fully_closed(), /*force*/ false);
  script:
    - id: minuet_cover_set
      parameters:
        open: bool
        force: bool
      then:
        - lambda: |-
            auto& cover = id(minuet_cover);
            if (open && (force || cover->position != COVER_OPEN || cover->current_operation == COVER_OPERATION_CLOSING)) {
              id(minuet_cover).make_call().set_command_open().perform();
            } else if (!open && (force || cover->position != COVER_CLOSED || cover->current_operation == COVER_OPERATION_OPENING)) {
              id(minuet_cover).make_call().set_command_close().perform();
            }
    - id: minuet_cover_perform_operation
      mode: restart
      parameters:
        open: bool
      then:
        - lambda: |-
            id(minuet_cover).current_operation = open ? COVER_OPERATION_OPENING : COVER_OPERATION_CLOSING;
            id(minuet_cover).publish_state();

            id(minuet_cover_motor_open).set_state(open);
            id(minuet_cover_motor_sleep).turn_off();
        - wait_until:
            condition:
              binary_sensor.is_on: minuet_cover_motor_fault # Wait for motor to stall
            timeout: 6s
        - lambda: |-
            id(minuet_cover_motor_sleep).turn_on();

            id(minuet_cover).current_operation = COVER_OPERATION_IDLE;
            id(minuet_cover).position = open ? COVER_OPEN : COVER_CLOSED;
            id(minuet_cover).publish_state();

# Record manually initiated state changes and distinguish them from automatic changes
minuet_manual_state:
  globals:
    - id: minuet_suppress_manual_state_change
      type: bool
      restore_value: false
      initial_value: "false"
  fan:
    - id: minuet_fan_manual_state
      platform: template
      has_direction: true
      speed_count: ${minuet_fan_speed_count}
      restore_mode: RESTORE_DEFAULT_OFF
  cover:
    - id: minuet_cover_manual_state
      platform: template
      optimistic: true
      assumed_state: true
      restore_mode: RESTORE
  script:
    - id: minuet_restore_manual_state
      parameters:
        force: bool
      then:
        - lambda: |-
            id(minuet_suppress_manual_state_change) = true;
            const auto& fan_manual = id(minuet_fan_manual_state);
            id(minuet_fan_set).execute(fan_manual->state, fan_manual->speed, fan_manual->direction,
                  /*suppress_cover_movement*/ true, force);
            const auto& cover_manual = id(minuet_cover_manual_state);
            id(minuet_cover_set).execute(cover_manual->is_fully_open(), force);
            id(minuet_suppress_manual_state_change) = false;

# Thermostat controller
#
# Both the user and the thermostat can modify the state of the same fan and cover entities.
# To resolve this conflict, the thermostat sets a flag whenever it changes the state so that
# the fan and cover state change handlers can distinguish whether a given change was initiated
# by the user or by the thermostat.  Only changes made by the user are ever saved to flash.
# When the thermostat is disabled, it restores the state of the fan and cover entities back
# to their manual settings.
#
# When using standard controls, the keypad forbids the user from changing the fan speed
# or cover position while the thermostat is enabled (because that's what the original firmware
# does).  However, the ESPHome API has no such constraints so if a manual change occurs
# through that interface then the thermostat is disabled to reconcile who's in charge.
#
# When using enhanced controls, the keypad allows the user to take control by incrementally
# modifying whatever state the thermostat last set the fan and cover to.  The thermostat
# remains enabled but powerless until the override flag is reset.  The same behavior applies
# to changes intiated by the ESPHome API.
#
# This design was chosen so that the fan and cover entities always reflect the true
# state of the device (insofar as it knows) and it ensures a smooth handoff of control back
# to the user when the thermostat is disabled or overridden.
minuet_thermostat:
  substitutions:
    minuet_thermostat_default_temperature: "78"
  globals:
    - id: minuet_thermostat_override
      type: bool
      restore_value: true
      initial_value: "false"
    - id: minuet_thermostat_auto_fan_speed
      type: int
      restore_value: false
      initial_value: "0"
    - id: minuet_thermostat_auto_fan_direction
      type: FanDirection
      restore_value: false
      initial_value: "FanDirection::REVERSE"
    - id: minuet_thermostat_auto_cover_open
      type: bool
      restore_value: false
      initial_value: "false"
  select:
    - id: minuet_controls
      platform: template
      name: "Controls"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Standard
        - Enhanced
      on_value:
        then:
          - lambda: |-
              if (i == 0) {
                // Reset some settings that can't be changed with the keypad using standard controls
                // although they can still be controlled via the ESPHome web app and API
                id(minuet_thermostat).make_call().set_fan_mode(CLIMATE_FAN_AUTO).perform();
                id(minuet_thermostat_fan_direction).make_call().select_first().perform();
                id(minuet_thermostat_reset_override).execute();
              }
    - id: minuet_thermostat_fan_direction
      platform: template
      name: "Vent Thermostat Fan Direction"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - Same as manual
        - Air out
        - Air in
      on_value:
        then:
          - script.execute: minuet_thermostat_update
  climate:
    - id: minuet_thermostat
      name: "Vent Thermostat"
      icon: mdi:thermostat-auto
      platform: thermostat
      sensor: minuet_ambient_temperature
      visual: # The IR remote uses Fahrenheit natively and expects the fan to do so as well
        min_temperature: 29Â°F
        max_temperature: 99Â°F
        temperature_step: 1Â°F
      cool_overrun: 2Â°F
      cool_deadband: 1Â°F
      min_idle_time: 0s
      min_cooling_off_time: 0s
      min_cooling_run_time: 0s
      min_fan_mode_switching_time: 0s
      idle_action:
        then:
          - script.execute: minuet_thermostat_update
      cool_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_auto_action:
        then:
          - script.execute: minuet_thermostat_update
      fan_mode_off_action:
        then:
          - script.execute: minuet_thermostat_update
      off_mode:
        then:
          - lambda: |-
              id(minuet_restore_manual_state).execute(/*force*/ false);
              id(minuet_thermostat_reset_override).execute();
      cool_mode:
        then:
          - lambda: |-
              // When the user turns on the thermostat, they're essentially saying that they
              // want the fan off unless the thermostat says otherwise, so record that intent
              // as a manual change.  That way when the fan doesn't come on unexpectedly when
              // the thermostat is disengaged or if a loss of power occurs.  Preserve the
              // fan speed and direction.
              id(minuet_fan_manual_state).make_call().set_state(false).perform();
              id(minuet_cover_manual_state).make_call().set_command_close().perform();
      on_state:
        then:
          - script.execute: minuet_thermostat_update
      preset:
        - name: 'Default'
          mode: 'off'
          fan_mode: 'auto'
          default_target_temperature_high: ${minuet_thermostat_default_temperature} Â°F
      default_preset: 'Default'
      on_boot_restore_from: memory
  binary_sensor:
    - id: minuet_thermostat_override_sensor
      name: "Vent Thermostat Overridden"
      icon: mdi:thermostat
      platform: template
      lambda: 'return id(minuet_thermostat_override);'
  button:
    - id: minuet_thermostat_reset_override_button
      name: "Vent Thermostat Reset Override"
      icon: mdi:thermostat
      platform: template
      on_press:
        then:
          - script.execute: minuet_thermostat_reset_override
  script:
    - id: minuet_thermostat_maybe_set_override
      then:
        - lambda: |-
            if (id(minuet_thermostat).mode != CLIMATE_MODE_OFF) {
              if (id(minuet_controls).active_index() == 1 /*Enhanced*/) {
                id(minuet_thermostat_override) = true;
                id(minuet_thermostat_update).execute();
              } else {
                id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
              }
            }
    - id: minuet_thermostat_reset_override
      then:
        - lambda: |-
            id(minuet_thermostat_override) = false;
            id(minuet_thermostat_update).execute();
    - id: minuet_thermostat_reconcile_fan_manual_state_change
      parameters:
        fan_state: bool
        fan_speed: int
        fan_direction: FanDirection
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_fan_speed) != (fan_state ? fan_speed : 0)
                || id(minuet_thermostat_auto_fan_direction) != fan_direction) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_reconcile_cover_manual_state_change
      parameters:
        cover_open: bool
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (id(minuet_thermostat_auto_cover_open) != cover_open) {
              id(minuet_thermostat_maybe_set_override).execute();
            }
    - id: minuet_thermostat_update
      then:
        - lambda: |-
            const auto& therm = id(minuet_thermostat);
            if (therm->mode != CLIMATE_MODE_OFF && !id(minuet_thermostat_override)) {
              auto& auto_fan_speed = id(minuet_thermostat_auto_fan_speed);
              auto& auto_fan_direction = id(minuet_thermostat_auto_fan_direction);
              auto& auto_cover_open = id(minuet_thermostat_auto_cover_open);
              if (id(minuet_thermostat).action == CLIMATE_ACTION_COOLING) {
                //const float ambient_temperature = therm->current_temperature;
                //const float target_temperature = therm->target_temperature_high;
                const auto& fan_mode = therm->fan_mode;
                auto_fan_speed = fan_mode == CLIMATE_FAN_AUTO ? 1 : 0; // TODO: choose a speed automatically
                auto_cover_open = true;
              } else {
                auto_fan_speed = 0;
                auto_cover_open = false;
              }
              id(minuet_suppress_manual_state_change) = true;
              if (auto_fan_speed != 0) {
                const auto& direction_index = id(minuet_thermostat_fan_direction).active_index();
                auto_fan_direction = direction_index == 1 ? FanDirection::REVERSE :
                    direction_index == 2 ? FanDirection::FORWARD : id(minuet_fan_manual_state).direction;
                id(minuet_fan_set).execute(true, auto_fan_speed, auto_fan_direction,
                    /*suppress_cover_movement*/ true, /*force*/ false);
              } else {
                auto_fan_direction = id(minuet_fan_manual_state).direction;
                id(minuet_fan_set).execute(false, id(minuet_fan_manual_state).speed, auto_fan_direction,
                    /*suppress_cover_movement*/ true, /*force*/ false);
              }
              id(minuet_cover_set).execute(auto_cover_open, /*force*/ false);
              id(minuet_suppress_manual_state_change) = false;
            }

# Configure whether the fan state is restored on boot
minuet_boot_restore:
  select:
    - id: minuet_power_on_behavior
      platform: template
      name: "Power On Behavior"
      entity_category: config
      optimistic: true
      restore_value: true
      options:
        - "Off"
        - "Restore"
  esphome:
    on_boot:
      - priority: 500
        then:
          - lambda: |-
              const auto& behavior = id(minuet_power_on_behavior).active_index();
              if (behavior == 0 || !behavior.has_value()) {
                id(minuet_fan_manual_state).make_call().set_state(false).perform();
                id(minuet_cover_manual_state).make_call().set_command_close().perform();
                id(minuet_thermostat).make_call().set_mode(CLIMATE_MODE_OFF).perform();
                id(minuet_thermostat_reset_override).execute();
              }
              id(minuet_restore_manual_state).execute(/*force*/ true);

# Shutdown behavior: Turn off the motors before ESPHome restarts, just in case.
minuet_shutdown:
  esphome:
    on_shutdown:
      - priority: 500
        then:
          - lambda: |-
              id(minuet_fan_motor_sleep).turn_on();
              id(minuet_cover_motor_sleep).turn_on();
